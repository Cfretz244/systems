BASH(1)                                                                BASH(1)



NNAAMMEE
       bash - GNU Bourne-Again SHell

SSYYNNOOPPSSIISS
       bbaasshh [options] [file]

CCOOPPYYRRIIGGHHTT
       Bash is Copyright (C) 1989-2009 by the Free Software Foundation, Inc.

DDEESSCCRRIIPPTTIIOONN
       BBaasshh  is  an  sshh-compatible  command language interpreter that executes
       commands read from the standard input or from a file.  BBaasshh also incor-
       porates useful features from the _K_o_r_n and _C shells (kksshh and ccsshh).

       BBaasshh  is  intended  to  be a conformant implementation of the Shell and
       Utilities portion  of  the  IEEE  POSIX  specification  (IEEE  Standard
       1003.1).  BBaasshh can be configured to be POSIX-conformant by default.

OOPPTTIIOONNSS
       In  addition  to  the  single-character shell options documented in the
       description of the sseett builtin command, bbaasshh interprets  the  following
       options when it is invoked:

       --cc _s_t_r_i_n_g If  the  --cc  option  is  present, then commands are read from
                 _s_t_r_i_n_g.  If there are arguments after the  _s_t_r_i_n_g,  they  are
                 assigned to the positional parameters, starting with $$00.
       --ii        If the --ii option is present, the shell is _i_n_t_e_r_a_c_t_i_v_e.
       --ll        Make bbaasshh act as if it had been invoked as a login shell (see
                 IINNVVOOCCAATTIIOONN below).
       --rr        If the --rr option is present,  the  shell  becomes  _r_e_s_t_r_i_c_t_e_d
                 (see RREESSTTRRIICCTTEEDD SSHHEELLLL below).
       --ss        If  the --ss option is present, or if no arguments remain after
                 option processing, then commands are read from  the  standard
                 input.   This  option  allows the positional parameters to be
                 set when invoking an interactive shell.
       --DD        A list of all double-quoted strings preceded by $$ is  printed
                 on  the standard output.  These are the strings that are sub-
                 ject to language translation when the current locale is not CC
                 or  PPOOSSIIXX.   This  implies the --nn option; no commands will be
                 executed.
       [[--++]]OO [[_s_h_o_p_t___o_p_t_i_o_n]]
                 _s_h_o_p_t___o_p_t_i_o_n is one of the  shell  options  accepted  by  the
                 sshhoopptt   builtin  (see  SSHHEELLLL  BBUUIILLTTIINN  CCOOMMMMAANNDDSS  below).   If
                 _s_h_o_p_t___o_p_t_i_o_n is present, --OO sets the value of that option; ++OO
                 unsets  it.   If  _s_h_o_p_t___o_p_t_i_o_n is not supplied, the names and
                 values of the shell options accepted by sshhoopptt are printed  on
                 the  standard  output.   If  the invocation option is ++OO, the
                 output is displayed in a format that may be reused as  input.
       ----        A  ----  signals the end of options and disables further option
                 processing.  Any arguments after the ---- are treated as  file-
                 names and arguments.  An argument of -- is equivalent to ----.

       BBaasshh  also  interprets  a  number  of  multi-character  options.  These
       options must appear on the command  line  before  the  single-character
       options to be recognized.

       ----ddeebbuuggggeerr
              Arrange for the debugger profile to be executed before the shell
              starts.  Turns on extended debugging mode (see  the  description
              of  the  eexxttddeebbuugg  option  to the sshhoopptt builtin below) and shell
              function tracing (see the description of the --oo ffuunnccttrraaccee option
              to the sseett builtin below).
       ----dduummpp--ppoo--ssttrriinnggss
              Equivalent  to  --DD,  but  the  output  is  in the GNU _g_e_t_t_e_x_t ppoo
              (portable object) file format.
       ----dduummpp--ssttrriinnggss
              Equivalent to --DD.
       ----hheellpp Display a usage message on standard  output  and  exit  success-
              fully.
       ----iinniitt--ffiillee _f_i_l_e
       ----rrccffiillee _f_i_l_e
              Execute commands from _f_i_l_e instead of the standard personal ini-
              tialization file _~_/_._b_a_s_h_r_c if  the  shell  is  interactive  (see
              IINNVVOOCCAATTIIOONN below).

       ----llooggiinn
              Equivalent to --ll.

       ----nnooeeddiittiinngg
              Do  not  use the GNU rreeaaddlliinnee library to read command lines when
              the shell is interactive.

       ----nnoopprrooffiillee
              Do not read either the system-wide startup file _/_e_t_c_/_p_r_o_f_i_l_e  or
              any   of  the  personal  initialization  files  _~_/_._b_a_s_h___p_r_o_f_i_l_e,
              _~_/_._b_a_s_h___l_o_g_i_n, or _~_/_._p_r_o_f_i_l_e.   By  default,  bbaasshh  reads  these
              files  when  it  is  invoked  as  a  login shell (see IINNVVOOCCAATTIIOONN
              below).

       ----nnoorrcc Do  not  read  and  execute  the  personal  initialization  file
              _~_/_._b_a_s_h_r_c  if  the  shell  is interactive.  This option is on by
              default if the shell is invoked as sshh.

       ----ppoossiixx
              Change the behavior of bbaasshh where the default operation  differs
              from the POSIX standard to match the standard (_p_o_s_i_x _m_o_d_e).

       ----rreessttrriicctteedd
              The shell becomes restricted (see RREESSTTRRIICCTTEEDD SSHHEELLLL below).

       ----rrppmm--rreeqquuiirreess
              Produce the list of files that are required for the shell script
              to run.  This implies ’-n’ and is subject to  the  same  limita-
              tions  as  compile  time  error checking checking; Backticks, []
              tests,  and evals are not parsed so  some  dependencies  may  be
              missed.

       ----vveerrbboossee
              Equivalent to  --vv.

       ----vveerrssiioonn
              Show  version information for this instance of bbaasshh on the stan-
              dard output and exit successfully.

AARRGGUUMMEENNTTSS
       If arguments remain after option processing, and neither the --cc nor the
       --ss  option  has  been supplied, the first argument is assumed to be the
       name of a file containing shell commands.  If bbaasshh is invoked  in  this
       fashion,  $$00 is set to the name of the file, and the positional parame-
       ters are set to the remaining arguments.  BBaasshh reads and executes  com-
       mands  from this file, then exits.  BBaasshh’s exit status is the exit sta-
       tus of the last command executed in the script.   If  no  commands  are
       executed,  the  exit status is 0.  An attempt is first made to open the
       file in the current directory, and, if no file is found, then the shell
       searches the directories in PPAATTHH for the script.

IINNVVOOCCAATTIIOONN
       A  _l_o_g_i_n _s_h_e_l_l is one whose first character of argument zero is a --, or
       one started with the ----llooggiinn option.

       An _i_n_t_e_r_a_c_t_i_v_e shell is one started without  non-option  arguments  and
       without the --cc option whose standard input and error are both connected
       to terminals (as determined by _i_s_a_t_t_y(3)), or one started with  the  --ii
       option.   PPSS11 is set and $$-- includes ii if bbaasshh is interactive, allowing
       a shell script or a startup file to test this state.

       The following paragraphs describe how bbaasshh executes its startup  files.
       If  any  of  the files exist but cannot be read, bbaasshh reports an error.
       Tildes are expanded in file names as described below under TTiillddee EExxppaann--
       ssiioonn in the EEXXPPAANNSSIIOONN section.

       When  bbaasshh is invoked as an interactive login shell, or as a non-inter-
       active shell with the ----llooggiinn option, it first reads and executes  com-
       mands  from  the file _/_e_t_c_/_p_r_o_f_i_l_e, if that file exists.  After reading
       that file, it looks for _~_/_._b_a_s_h___p_r_o_f_i_l_e, _~_/_._b_a_s_h___l_o_g_i_n, and _~_/_._p_r_o_f_i_l_e,
       in  that order, and reads and executes commands from the first one that
       exists and is readable.  The ----nnoopprrooffiillee option may be  used  when  the
       shell is started to inhibit this behavior.

       When  a  login  shell  exits, bbaasshh reads and executes commands from the
       files _~_/_._b_a_s_h___l_o_g_o_u_t and _/_e_t_c_/_b_a_s_h_._b_a_s_h___l_o_g_o_u_t, if the files exists.

       When an interactive shell that is not a login shell  is  started,  bbaasshh
       reads  and executes commands from _~_/_._b_a_s_h_r_c, if that file exists.  This
       may be inhibited by using the ----nnoorrcc option.  The ----rrccffiillee _f_i_l_e  option
       will  force  bbaasshh  to  read  and  execute commands from _f_i_l_e instead of
       _~_/_._b_a_s_h_r_c.

       When bbaasshh is started non-interactively, to  run  a  shell  script,  for
       example, it looks for the variable BBAASSHH__EENNVV in the environment, expands
       its value if it appears there, and uses the expanded value as the  name
       of  a  file to read and execute.  BBaasshh behaves as if the following com-
       mand were executed:
              if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
       but the value of the PPAATTHH variable is not used to search for  the  file
       name.

       If  bbaasshh  is  invoked  with  the name sshh, it tries to mimic the startup
       behavior of historical versions of sshh as  closely  as  possible,  while
       conforming  to the POSIX standard as well.  When invoked as an interac-
       tive login shell, or a non-interactive shell with the  ----llooggiinn  option,
       it  first  attempts  to read and execute commands from _/_e_t_c_/_p_r_o_f_i_l_e and
       _~_/_._p_r_o_f_i_l_e, in that order.  The  ----nnoopprrooffiillee  option  may  be  used  to
       inhibit  this  behavior.  When invoked as an interactive shell with the
       name sshh, bbaasshh looks for the variable EENNVV, expands its value  if  it  is
       defined,  and uses the expanded value as the name of a file to read and
       execute.  Since a shell invoked as sshh does not attempt to read and exe-
       cute  commands from any other startup files, the ----rrccffiillee option has no
       effect.  A non-interactive shell invoked with  the  name  sshh  does  not
       attempt  to  read  any  other  startup files.  When invoked as sshh, bbaasshh
       enters _p_o_s_i_x mode after the startup files are read.

       When bbaasshh is started in _p_o_s_i_x mode, as with the  ----ppoossiixx  command  line
       option, it follows the POSIX standard for startup files.  In this mode,
       interactive shells expand the EENNVV variable and commands  are  read  and
       executed  from  the  file  whose  name is the expanded value.  No other
       startup files are read.

       BBaasshh attempts to determine when it is being run with its standard input
       connected  to a a network connection, as if by the remote shell daemon,
       usually _r_s_h_d, or the secure shell daemon _s_s_h_d.  If bbaasshh  determines  it
       is  being  run  in  this  fashion,  it reads and executes commands from
       _~_/_._b_a_s_h_r_c, if that file exists and is readable.  It will not do this if
       invoked as sshh.  The ----nnoorrcc option may be used to inhibit this behavior,
       and the ----rrccffiillee option may be used to force another file to  be  read,
       but  _r_s_h_d  does  not  generally  invoke the shell with those options or
       allow them to be specified.

       If the shell is started with the effective user (group) id not equal to
       the real user (group) id, and the --pp option is not supplied, no startup
       files are read, shell functions are not inherited from the environment,
       the  SSHHEELLLLOOPPTTSS,  BBAASSHHOOPPTTSS,  CCDDPPAATTHH,  and  GGLLOOBBIIGGNNOORREE variables, if they
       appear in the environment, are ignored, and the effective  user  id  is
       set  to  the real user id.  If the --pp option is supplied at invocation,
       the startup behavior is the same, but the  effective  user  id  is  not
       reset.

DDEEFFIINNIITTIIOONNSS
       The  following  definitions  are used throughout the rest of this docu-
       ment.
       bbllaannkk  A space or tab.
       wwoorrdd   A sequence of characters considered as  a  single  unit  by  the
              shell.  Also known as a ttookkeenn.
       nnaammee   A  _w_o_r_d  consisting  only  of alphanumeric characters and under-
              scores, and beginning with an alphabetic character or an  under-
              score.  Also referred to as an iiddeennttiiffiieerr.
       mmeettaacchhaarraacctteerr
              A  character  that,  when unquoted, separates words.  One of the
              following:
              ||  && ;; (( )) << >> ssppaaccee ttaabb
       ccoonnttrrooll ooppeerraattoorr
              A _t_o_k_e_n that performs a control function.  It is one of the fol-
              lowing symbols:
              |||| && &&&& ;; ;;;; (( )) || ||&& <<nneewwlliinnee>>

RREESSEERRVVEEDD WWOORRDDSS
       _R_e_s_e_r_v_e_d _w_o_r_d_s are words that have a special meaning to the shell.  The
       following words are recognized as reserved when unquoted and either the
       first  word  of a simple command (see SSHHEELLLL GGRRAAMMMMAARR below) or the third
       word of a ccaassee or ffoorr command:

       !! ccaassee  ddoo ddoonnee eelliiff eellssee eessaacc ffii ffoorr ffuunnccttiioonn iiff iinn sseelleecctt tthheenn  uunnttiill
       wwhhiillee {{ }} ttiimmee [[[[ ]]]]

SSHHEELLLL GGRRAAMMMMAARR
   SSiimmppllee CCoommmmaannddss
       A  _s_i_m_p_l_e  _c_o_m_m_a_n_d  is a sequence of optional variable assignments fol-
       lowed by bbllaannkk-separated words and redirections, and  terminated  by  a
       _c_o_n_t_r_o_l _o_p_e_r_a_t_o_r.  The first word specifies the command to be executed,
       and is passed as argument zero.  The  remaining  words  are  passed  as
       arguments to the invoked command.

       The  return  value  of a _s_i_m_p_l_e _c_o_m_m_a_n_d is its exit status, or 128+_n if
       the command is terminated by signal _n.

   PPiippeelliinneess
       A _p_i_p_e_l_i_n_e is a sequence of one or more commands separated  by  one  of
       the control operators || or ||&&.  The format for a pipeline is:

              [ttiimmee [--pp]] [ ! ] _c_o_m_m_a_n_d [ [||│||&&] _c_o_m_m_a_n_d_2 ... ]

       The  standard output of _c_o_m_m_a_n_d is connected via a pipe to the standard
       input of _c_o_m_m_a_n_d_2.  This connection is performed  before  any  redirec-
       tions specified by the command (see RREEDDIIRREECCTTIIOONN below).  If ||&& is used,
       the standard error of _c_o_m_m_a_n_d is connected to _c_o_m_m_a_n_d_2’s standard input
       through  the  pipe; it is shorthand for 22>>&&11 ||.  This implicit redirec-
       tion of the standard error is performed after any  redirections  speci-
       fied by the command.

       The return status of a pipeline is the exit status of the last command,
       unless the ppiippeeffaaiill option is enabled.  If  ppiippeeffaaiill  is  enabled,  the
       pipeline’s  return  status is the value of the last (rightmost) command
       to  exit  with  a  non-zero  status,  or  zero  if  all  commands  exit
       successfully.   If  the  reserved word !!  precedes a pipeline, the exit
       status of that pipeline is the logical negation of the exit  status  as
       described  above.   The shell waits for all commands in the pipeline to
       terminate before returning a value.

       If the ttiimmee reserved word precedes a pipeline, the elapsed as  well  as
       user  and  system  time consumed by its execution are reported when the
       pipeline terminates.  The --pp option changes the output format  to  that
       specified  by  POSIX.   The  TTIIMMEEFFOORRMMAATT variable may be set to a format
       string that specifies how the timing information should  be  displayed;
       see the description of TTIIMMEEFFOORRMMAATT under SShheellll VVaarriiaabblleess below.

       Each  command in a pipeline is executed as a separate process (i.e., in
       a subshell).

   LLiissttss
       A _l_i_s_t is a sequence of one or more pipelines separated by one  of  the
       operators ;;, &&, &&&&, or ││││, and optionally terminated by one of ;;, &&, or
       <<nneewwlliinnee>>.

       Of these list operators, &&&& and ││││ have equal precedence, followed by ;;
       and &&, which have equal precedence.

       A  sequence  of  one or more newlines may appear in a _l_i_s_t instead of a
       semicolon to delimit commands.

       If a command is terminated by the control operator &&,  the  shell  exe-
       cutes  the command in the _b_a_c_k_g_r_o_u_n_d in a subshell.  The shell does not
       wait for the command to finish, and the return status is  0.   Commands
       separated  by  a  ;; are executed sequentially; the shell waits for each
       command to terminate in turn.  The return status is the exit status  of
       the last command executed.

       AND  and  OR  lists are sequences of one of more pipelines separated by
       the &&&& and ││││ control operators, respectively.  AND and  OR  lists  are
       executed with left associativity.  An AND list has the form

              _c_o_m_m_a_n_d_1 &&&& _c_o_m_m_a_n_d_2

       _c_o_m_m_a_n_d_2  is  executed if, and only if, _c_o_m_m_a_n_d_1 returns an exit status
       of zero.

       An OR list has the form

              _c_o_m_m_a_n_d_1 ││││ _c_o_m_m_a_n_d_2


       _c_o_m_m_a_n_d_2 is executed if and only if _c_o_m_m_a_n_d_1 returns  a  non-zero  exit
       status.   The  return  status of AND and OR lists is the exit status of
       the last command executed in the list.

   CCoommppoouunndd CCoommmmaannddss
       A _c_o_m_p_o_u_n_d _c_o_m_m_a_n_d is one of the following:

       (_l_i_s_t) _l_i_s_t is executed in a subshell environment (see  CCOOMMMMAANNDD  EEXXEECCUU--
              TTIIOONN  EENNVVIIRROONNMMEENNTT below).  Variable assignments and builtin com-
              mands that affect the  shell’s  environment  do  not  remain  in
              effect  after  the  command completes.  The return status is the
              exit status of _l_i_s_t.

       { _l_i_s_t; }
              _l_i_s_t is simply executed in the current shell environment.   _l_i_s_t
              must  be  terminated with a newline or semicolon.  This is known
              as a _g_r_o_u_p _c_o_m_m_a_n_d.  The return status is  the  exit  status  of
              _l_i_s_t.   Note that unlike the metacharacters (( and )), {{ and }} are
              _r_e_s_e_r_v_e_d _w_o_r_d_s and must occur where a reserved word is permitted
              to  be  recognized.   Since they do not cause a word break, they
              must be separated from  _l_i_s_t  by  whitespace  or  another  shell
              metacharacter.

       ((_e_x_p_r_e_s_s_i_o_n))
              The  _e_x_p_r_e_s_s_i_o_n  is  evaluated  according to the rules described
              below under AARRIITTHHMMEETTIICC EEVVAALLUUAATTIIOONN.  If the value of the  expres-
              sion  is  non-zero, the return status is 0; otherwise the return
              status is 1.  This is exactly equivalent to lleett ""_e_x_p_r_e_s_s_i_o_n"".

       [[[[ _e_x_p_r_e_s_s_i_o_n ]]]]
              Return a status of 0 or 1 depending on  the  evaluation  of  the
              conditional  expression _e_x_p_r_e_s_s_i_o_n.  Expressions are composed of
              the primaries described  below  under  CCOONNDDIITTIIOONNAALL  EEXXPPRREESSSSIIOONNSS.
              Word  splitting  and pathname expansion are not performed on the
              words between the [[[[ and  ]]]];  tilde  expansion,  parameter  and
              variable  expansion, arithmetic expansion, command substitution,
              process substitution, and quote removal are  performed.   Condi-
              tional operators such as --ff must be unquoted to be recognized as
              primaries.

              When used with [[[[, The << and >> operators sort  lexicographically
              using the current locale.

              When  the  ==== and !!== operators are used, the string to the right
              of the operator is considered a pattern and matched according to
              the  rules described below under PPaatttteerrnn MMaattcchhiinngg.  If the shell
              option nnooccaasseemmaattcchh is enabled, the match  is  performed  without
              regard  to  the case of alphabetic characters.  The return value
              is 0 if the string matches (====) or does not match (!!==) the  pat-
              tern, and 1 otherwise.  Any part of the pattern may be quoted to
              force it to be matched as a string.

              An additional binary operator, ==~~, is available, with  the  same
              precedence  as  ====  and  !!==.  When it is used, the string to the
              right of the operator is considered an extended regular  expres-
              sion and matched accordingly (as in _r_e_g_e_x(3)).  The return value
              is 0 if the string matches the pattern, and 1 otherwise.  If the
              regular  expression  is syntactically incorrect, the conditional
              expression’s return value is 2.  If the shell option nnooccaasseemmaattcchh
              is enabled, the match is performed without regard to the case of
              alphabetic characters.  Any part of the pattern may be quoted to
              force  it  to  be  matched  as  a string.  Substrings matched by
              parenthesized subexpressions within the regular  expression  are
              saved  in  the  array  variable  BBAASSHH__RREEMMAATTCCHH.   The  element of
              BBAASSHH__RREEMMAATTCCHH with index 0 is the portion of the string  matching
              the entire regular expression.  The element of BBAASSHH__RREEMMAATTCCHH with
              index _n is the portion of the string matching the _nth  parenthe-
              sized subexpression.

              Expressions  may  be  combined  using  the  following operators,
              listed in decreasing order of precedence:

              (( _e_x_p_r_e_s_s_i_o_n ))
                     Returns the value of _e_x_p_r_e_s_s_i_o_n.  This  may  be  used  to
                     override the normal precedence of operators.
              !! _e_x_p_r_e_s_s_i_o_n
                     True if _e_x_p_r_e_s_s_i_o_n is false.
              _e_x_p_r_e_s_s_i_o_n_1 &&&& _e_x_p_r_e_s_s_i_o_n_2
                     True if both _e_x_p_r_e_s_s_i_o_n_1 and _e_x_p_r_e_s_s_i_o_n_2 are true.
              _e_x_p_r_e_s_s_i_o_n_1 |||| _e_x_p_r_e_s_s_i_o_n_2
                     True if either _e_x_p_r_e_s_s_i_o_n_1 or _e_x_p_r_e_s_s_i_o_n_2 is true.

              The &&&& and |||| operators do not evaluate _e_x_p_r_e_s_s_i_o_n_2 if the value
              of _e_x_p_r_e_s_s_i_o_n_1 is sufficient to determine the  return  value  of
              the entire conditional expression.

       ffoorr _n_a_m_e [ [ iinn [ _w_o_r_d _._._. ] ] ; ] ddoo _l_i_s_t ; ddoonnee
              The list of words following iinn is expanded, generating a list of
              items.  The variable _n_a_m_e is set to each element of this list in
              turn,  and  _l_i_s_t is executed each time.  If the iinn _w_o_r_d is omit-
              ted, the ffoorr command executes  _l_i_s_t  once  for  each  positional
              parameter that is set (see PPAARRAAMMEETTEERRSS below).  The return status
              is the exit status of the last command that  executes.   If  the
              expansion of the items following iinn results in an empty list, no
              commands are executed, and the return status is 0.

       ffoorr (( _e_x_p_r_1 ; _e_x_p_r_2 ; _e_x_p_r_3 )) ; ddoo _l_i_s_t ; ddoonnee
              First, the arithmetic expression _e_x_p_r_1 is evaluated according to
              the  rules  described  below  under  AARRIITTHHMMEETTIICC EEVVAALLUUAATTIIOONN.  The
              arithmetic expression _e_x_p_r_2 is then evaluated  repeatedly  until
              it  evaluates  to zero.  Each time _e_x_p_r_2 evaluates to a non-zero
              value, _l_i_s_t is executed and the arithmetic expression  _e_x_p_r_3  is
              evaluated.   If  any  expression is omitted, it behaves as if it
              evaluates to 1.  The return value is the exit status of the last
              command in _l_i_s_t that is executed, or false if any of the expres-
              sions is invalid.

       sseelleecctt _n_a_m_e [ iinn _w_o_r_d ] ; ddoo _l_i_s_t ; ddoonnee
              The list of words following iinn is expanded, generating a list of
              items.   The  set  of  expanded words is printed on the standard
              error, each preceded by a number.  If the iinn  _w_o_r_d  is  omitted,
              the  positional  parameters  are printed (see PPAARRAAMMEETTEERRSS below).
              The PPSS33 prompt is then displayed and a line read from the  stan-
              dard  input.   If the line consists of a number corresponding to
              one of the displayed words, then the value of  _n_a_m_e  is  set  to
              that  word.  If the line is empty, the words and prompt are dis-
              played again.  If EOF is read, the command completes.  Any other
              value  read  causes  _n_a_m_e  to  be set to null.  The line read is
              saved in the variable RREEPPLLYY.  The _l_i_s_t is  executed  after  each
              selection until a bbrreeaakk command is executed.  The exit status of
              sseelleecctt is the exit status of the last command executed in  _l_i_s_t,
              or zero if no commands were executed.

       ccaassee _w_o_r_d iinn [ [(] _p_a_t_t_e_r_n [ || _p_a_t_t_e_r_n ] ... ) _l_i_s_t ;; ] ... eessaacc
              A ccaassee command first expands _w_o_r_d, and tries to match it against
              each _p_a_t_t_e_r_n in turn, using the same matching rules as for path-
              name  expansion  (see  PPaatthhnnaammee  EExxppaannssiioonn  below).  The _w_o_r_d is
              expanded using tilde expansion, parameter  and  variable  expan-
              sion,  arithmetic  substitution,  command  substitution, process
              substitution  and  quote  removal.   Each  _p_a_t_t_e_r_n  examined  is
              expanded  using  tilde  expansion, parameter and variable expan-
              sion, arithmetic substitution, command substitution, and process
              substitution.   If  the shell option nnooccaasseemmaattcchh is enabled, the
              match is performed without regard  to  the  case  of  alphabetic
              characters.   When  a  match is found, the corresponding _l_i_s_t is
              executed.  If the ;;;; operator is used, no subsequent matches are
              attempted  after  the first pattern match.  Using ;;&& in place of
              ;;;; causes execution to continue with the  _l_i_s_t  associated  with
              the  next  set of patterns.  Using ;;;;&& in place of ;;;; causes the
              shell to test the next pattern list in the  statement,  if  any,
              and execute any associated _l_i_s_t on a successful match.  The exit
              status is zero if no pattern matches.  Otherwise, it is the exit
              status of the last command executed in _l_i_s_t.

       iiff _l_i_s_t; tthheenn _l_i_s_t_; [ eelliiff _l_i_s_t; tthheenn _l_i_s_t; ] ... [ eellssee _l_i_s_t; ] ffii
              The  iiff  _l_i_s_t is executed.  If its exit status is zero, the tthheenn
              _l_i_s_t is executed.  Otherwise, each  eelliiff  _l_i_s_t  is  executed  in
              turn,  and  if  its  exit status is zero, the corresponding tthheenn
              _l_i_s_t is executed and the command completes.  Otherwise, the eellssee
              _l_i_s_t  is executed, if present.  The exit status is the exit sta-
              tus of the last command executed, or zero if no condition tested
              true.

       wwhhiillee _l_i_s_t; ddoo _l_i_s_t; ddoonnee
       uunnttiill _l_i_s_t; ddoo _l_i_s_t; ddoonnee
              The  wwhhiillee  command continuously executes the ddoo _l_i_s_t as long as
              the last command in _l_i_s_t returns an exit status  of  zero.   The
              uunnttiill command is identical to the wwhhiillee command, except that the
              test is negated; the ddoo _l_i_s_t is executed as  long  as  the  last
              command in _l_i_s_t returns a non-zero exit status.  The exit status
              of the wwhhiillee and uunnttiill commands is the exit status of  the  last
              ddoo _l_i_s_t command executed, or zero if none was executed.

   CCoopprroocceesssseess
       A _c_o_p_r_o_c_e_s_s is a shell command preceded by the ccoopprroocc reserved word.  A
       coprocess is executed asynchronously in a subshell, as if  the  command
       had  been  terminated  with the && control operator, with a two-way pipe
       established between the executing shell and the coprocess.

       The format for a coprocess is:

              ccoopprroocc [_N_A_M_E] _c_o_m_m_a_n_d [_r_e_d_i_r_e_c_t_i_o_n_s]

       This creates a coprocess named _N_A_M_E.  If  _N_A_M_E  is  not  supplied,  the
       default name is _C_O_P_R_O_C.  _N_A_M_E must not be supplied if _c_o_m_m_a_n_d is a _s_i_m_-
       _p_l_e _c_o_m_m_a_n_d (see above); otherwise, it is interpreted as the first word
       of  the simple command.  When the coproc is executed, the shell creates
       an array variable (see AArrrraayyss below) named _N_A_M_E in the context  of  the
       executing  shell.   The  standard  output of _c_o_m_m_a_n_d is connected via a
       pipe to a file  descriptor  in  the  executing  shell,  and  that  file
       descriptor  is  assigned  to _N_A_M_E[0].  The standard input of _c_o_m_m_a_n_d is
       connected via a pipe to a file descriptor in the executing  shell,  and
       that  file descriptor is assigned to _N_A_M_E[1].  This pipe is established
       before any redirections  specified  by  the  command  (see  RREEDDIIRREECCTTIIOONN
       below).   The  file  descriptors  can be utilized as arguments to shell
       commands and redirections using standard word expansions.  The  process
       id  of  the  shell spawned to execute the coprocess is available as the
       value of the variable _N_A_M_E_PID.  The wwaaiitt builtin command may  be  used
       to wait for the coprocess to terminate.

       The return status of a coprocess is the exit status of _c_o_m_m_a_n_d.

   SShheellll FFuunnccttiioonn DDeeffiinniittiioonnss
       A  shell function is an object that is called like a simple command and
       executes a compound command with a new set  of  positional  parameters.
       Shell functions are declared as follows:

       [ ffuunnccttiioonn ] _n_a_m_e () _c_o_m_p_o_u_n_d_-_c_o_m_m_a_n_d [_r_e_d_i_r_e_c_t_i_o_n]
              This  defines a function named _n_a_m_e.  The reserved word ffuunnccttiioonn
              is optional.  If the ffuunnccttiioonn reserved  word  is  supplied,  the
              parentheses  are optional.  The _b_o_d_y of the function is the com-
              pound command _c_o_m_p_o_u_n_d_-_c_o_m_m_a_n_d (see  CCoommppoouunndd  CCoommmmaannddss  above).
              That  command is usually a _l_i_s_t of commands between { and }, but
              may be any command listed under CCoommppoouunndd CCoommmmaannddss  above.   _c_o_m_-
              _p_o_u_n_d_-_c_o_m_m_a_n_d is executed whenever _n_a_m_e is specified as the name
              of a simple command.  Any redirections (see  RREEDDIIRREECCTTIIOONN  below)
              specified  when  a  function  is  defined are performed when the
              function is executed.  The exit status of a function  definition
              is zero unless a syntax error occurs or a readonly function with
              the same name already exists.  When executed, the exit status of
              a  function  is  the exit status of the last command executed in
              the body.  (See FFUUNNCCTTIIOONNSS below.)

CCOOMMMMEENNTTSS
       In a non-interactive shell, or an interactive shell in which the iinntteerr--
       aaccttiivvee__ccoommmmeennttss  option  to  the  sshhoopptt  builtin  is enabled (see SSHHEELLLL
       BBUUIILLTTIINN CCOOMMMMAANNDDSS below), a word beginning with ## causes that  word  and
       all  remaining  characters  on that line to be ignored.  An interactive
       shell without the iinntteerraaccttiivvee__ccoommmmeennttss option enabled  does  not  allow
       comments.  The iinntteerraaccttiivvee__ccoommmmeennttss option is on by default in interac-
       tive shells.

QQUUOOTTIINNGG
       _Q_u_o_t_i_n_g is used to remove the special meaning of certain characters  or
       words  to  the shell.  Quoting can be used to disable special treatment
       for special characters, to prevent reserved words from being recognized
       as such, and to prevent parameter expansion.

       Each  of  the _m_e_t_a_c_h_a_r_a_c_t_e_r_s listed above under DDEEFFIINNIITTIIOONNSS has special
       meaning to the shell and must be quoted if it is to represent itself.

       When the command history expansion facilities are being used (see  HHIISS--
       TTOORRYY EEXXPPAANNSSIIOONN below), the _h_i_s_t_o_r_y _e_x_p_a_n_s_i_o_n character, usually !!, must
       be quoted to prevent history expansion.

       There are  three  quoting  mechanisms:  the  _e_s_c_a_p_e  _c_h_a_r_a_c_t_e_r,  single
       quotes, and double quotes.

       A  non-quoted  backslash (\\) is the _e_s_c_a_p_e _c_h_a_r_a_c_t_e_r.  It preserves the
       literal value of the next character that follows, with the exception of
       <newline>.   If  a  \\<newline>  pair  appears, and the backslash is not
       itself quoted, the \\<newline> is treated as a line  continuation  (that
       is, it is removed from the input stream and effectively ignored).

       Enclosing  characters  in  single quotes preserves the literal value of
       each character within the quotes.  A single quote may not occur between
       single quotes, even when preceded by a backslash.

       Enclosing  characters  in  double quotes preserves the literal value of
       all characters within the quotes, with the exception of $$, ``,  \\,  and,
       when  history  expansion  is enabled, !!.  The characters $$ and `` retain
       their special meaning within double quotes.  The backslash retains  its
       special  meaning only when followed by one of the following characters:
       $$, ``, "", \\, or <<nneewwlliinnee>>.  A double quote may be quoted  within  double
       quotes by preceding it with a backslash.  If enabled, history expansion
       will be performed unless an !!  appearing in double  quotes  is  escaped
       using a backslash.  The backslash preceding the !!  is not removed.

       The  special  parameters  **  and  @@ have special meaning when in double
       quotes (see PPAARRAAMMEETTEERRSS below).

       Words of the form $$'_s_t_r_i_n_g' are treated specially.  The word expands to
       _s_t_r_i_n_g,  with backslash-escaped characters replaced as specified by the
       ANSI C standard.  Backslash escape sequences, if present,  are  decoded
       as follows:
              \\aa     alert (bell)
              \\bb     backspace
              \\ee
              \\EE     an escape character
              \\ff     form feed
              \\nn     new line
              \\rr     carriage return
              \\tt     horizontal tab
              \\vv     vertical tab
              \\\\     backslash
              \\''     single quote
              \\""     double quote
              \\_n_n_n   the  eight-bit  character  whose value is the octal value
                     _n_n_n (one to three digits)
              \\xx_H_H   the eight-bit character whose value  is  the  hexadecimal
                     value _H_H (one or two hex digits)
              \\cc_x    a control-_x character

       The  expanded  result  is  single-quoted, as if the dollar sign had not
       been present.

       A double-quoted string preceded by a dollar sign ($$"_s_t_r_i_n_g") will cause
       the  string  to  be translated according to the current locale.  If the
       current locale is CC or PPOOSSIIXX, the  dollar  sign  is  ignored.   If  the
       string is translated and replaced, the replacement is double-quoted.

PPAARRAAMMEETTEERRSS
       A  _p_a_r_a_m_e_t_e_r is an entity that stores values.  It can be a _n_a_m_e, a num-
       ber, or one of the special characters listed below under SSppeecciiaall PPaarraamm--
       eetteerrss.   A _v_a_r_i_a_b_l_e is a parameter denoted by a _n_a_m_e.  A variable has a
       _v_a_l_u_e and zero or more _a_t_t_r_i_b_u_t_e_s.  Attributes are assigned  using  the
       ddeeccllaarree  builtin command (see ddeeccllaarree below in SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS).

       A parameter is set if it has been assigned a value.  The null string is
       a  valid  value.  Once a variable is set, it may be unset only by using
       the uunnsseett builtin command (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).

       A _v_a_r_i_a_b_l_e may be assigned to by a statement of the form

              _n_a_m_e=[_v_a_l_u_e]

       If _v_a_l_u_e is not given, the variable is assigned the null  string.   All
       _v_a_l_u_e_s  undergo tilde expansion, parameter and variable expansion, com-
       mand substitution, arithmetic expansion, and quote removal (see  EEXXPPAANN--
       SSIIOONN below).  If the variable has its iinntteeggeerr attribute set, then _v_a_l_u_e
       is evaluated as an arithmetic expression even if the $((...)) expansion
       is  not  used  (see AArriitthhmmeettiicc EExxppaannssiioonn below).  Word splitting is not
       performed, with the exception of ""$$@@"" as explained below under  SSppeecciiaall
       PPaarraammeetteerrss.   Pathname  expansion  is not performed.  Assignment state-
       ments may also appear as arguments  to  the  aalliiaass,  ddeeccllaarree,  ttyyppeesseett,
       eexxppoorrtt, rreeaaddoonnllyy, and llooccaall builtin commands.

       In  the context where an assignment statement is assigning a value to a
       shell variable or array index, the += operator can be used to append to
       or add to the variable’s previous value.  When += is applied to a vari-
       able for which the integer attribute has been set, _v_a_l_u_e  is  evaluated
       as  an arithmetic expression and added to the variable’s current value,
       which is also evaluated.  When += is applied to an array variable using
       compound  assignment  (see  AArrrraayyss  below), the variable’s value is not
       unset (as it is when using =), and new values are appended to the array
       beginning  at  one  greater than the array’s maximum index (for indexed
       arrays) or added as additional key-value pairs in an associative array.
       When  applied  to  a  string-valued  variable,  _v_a_l_u_e  is  expanded and
       appended to the variable’s value.

   PPoossiittiioonnaall PPaarraammeetteerrss
       A _p_o_s_i_t_i_o_n_a_l _p_a_r_a_m_e_t_e_r is a parameter denoted by one  or  more  digits,
       other than the single digit 0.  Positional parameters are assigned from
       the shell’s arguments when it is invoked, and may be  reassigned  using
       the  sseett builtin command.  Positional parameters may not be assigned to
       with assignment statements.  The positional parameters are  temporarily
       replaced when a shell function is executed (see FFUUNNCCTTIIOONNSS below).

       When  a  positional parameter consisting of more than a single digit is
       expanded, it must be enclosed in braces (see EEXXPPAANNSSIIOONN below).

   SSppeecciiaall PPaarraammeetteerrss
       The shell treats several parameters specially.   These  parameters  may
       only be referenced; assignment to them is not allowed.
       **      Expands  to  the positional parameters, starting from one.  When
              the expansion occurs within double quotes, it expands to a  sin-
              gle word with the value of each parameter separated by the first
              character of the IIFFSS special variable.  That is, "$$**" is equiva-
              lent to "$$11_c$$22_c......", where _c is the first character of the value
              of the IIFFSS variable.  If IIFFSS is unset, the parameters are  sepa-
              rated  by  spaces.   If  IIFFSS  is null, the parameters are joined
              without intervening separators.
       @@      Expands to the positional parameters, starting from  one.   When
              the  expansion  occurs  within  double  quotes,  each  parameter
              expands to a separate word.  That is, "$$@@" is equivalent to "$$11"
              "$$22"  ...   If the double-quoted expansion occurs within a word,
              the expansion of the first parameter is joined with  the  begin-
              ning  part  of  the original word, and the expansion of the last
              parameter is joined with the last part  of  the  original  word.
              When  there  are no positional parameters, "$$@@" and $$@@ expand to
              nothing (i.e., they are removed).
       ##      Expands to the number of positional parameters in decimal.
       ??      Expands to the exit status of the most recently  executed  fore-
              ground pipeline.
       --      Expands  to  the  current option flags as specified upon invoca-
              tion, by the sseett builtin command, or  those  set  by  the  shell
              itself (such as the --ii option).
       $$      Expands  to  the  process ID of the shell.  In a () subshell, it
              expands to the process ID of the current  shell,  not  the  sub-
              shell.
       !!      Expands  to  the  process ID of the most recently executed back-
              ground (asynchronous) command.
       00      Expands to the name of the shell or shell script.  This  is  set
              at shell initialization.  If bbaasshh is invoked with a file of com-
              mands, $$00 is set to the name of that file.  If bbaasshh  is  started
              with  the  --cc option, then $$00 is set to the first argument after
              the string to be executed, if one is present.  Otherwise, it  is
              set  to  the file name used to invoke bbaasshh, as given by argument
              zero.
       __      At shell startup, set to the absolute pathname  used  to  invoke
              the  shell or shell script being executed as passed in the envi-
              ronment or argument list.  Subsequently,  expands  to  the  last
              argument  to the previous command, after expansion.  Also set to
              the full pathname used  to  invoke  each  command  executed  and
              placed in the environment exported to that command.  When check-
              ing mail, this parameter holds the name of the  mail  file  cur-
              rently being checked.

   SShheellll VVaarriiaabblleess
       The following variables are set by the shell:

       BBAASSHH   Expands  to  the  full file name used to invoke this instance of
              bbaasshh.
       BBAASSHHOOPPTTSS
              A colon-separated list of enabled shell options.  Each  word  in
              the  list  is  a  valid  argument for the --ss option to the sshhoopptt
              builtin command (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).  The options
              appearing  in  BBAASSHHOOPPTTSS  are  those reported as _o_n by sshhoopptt.  If
              this variable is in the environment when bbaasshh  starts  up,  each
              shell  option  in  the  list  will be enabled before reading any
              startup files.  This variable is read-only.
       BBAASSHHPPIIDD
              Expands to the process id of the  current  bbaasshh  process.   This
              differs  from  $$$$ under certain circumstances, such as subshells
              that do not require bbaasshh to be re-initialized.
       BBAASSHH__AALLIIAASSEESS
              An associative array variable whose members  correspond  to  the
              internal list of aliases as maintained by the aalliiaass builtin Ele-
              ments added to this array appear in the  alias  list;  unsetting
              array  elements cause aliases to be removed from the alias list.
       BBAASSHH__AARRGGCC
              An array variable whose values are the number of  parameters  in
              each frame of the current bbaasshh execution call stack.  The number
              of parameters to  the  current  subroutine  (shell  function  or
              script  executed  with  .. or ssoouurrccee) is at the top of the stack.
              When a subroutine is executed, the number of  parameters  passed
              is pushed onto BBAASSHH__AARRGGCC.  The shell sets BBAASSHH__AARRGGCC only when in
              extended debugging mode (see the  description  of  the  eexxttddeebbuugg
              option to the sshhoopptt builtin below)
       BBAASSHH__AARRGGVV
              An  array  variable containing all of the parameters in the cur-
              rent bbaasshh execution call stack.  The final parameter of the last
              subroutine  call is at the top of the stack; the first parameter
              of the initial call is at the bottom.  When a subroutine is exe-
              cuted,  the  parameters supplied are pushed onto BBAASSHH__AARRGGVV.  The
              shell sets BBAASSHH__AARRGGVV only when in extended debugging  mode  (see
              the  description  of  the  eexxttddeebbuugg  option to the sshhoopptt builtin
              below)
       BBAASSHH__CCMMDDSS
              An associative array variable whose members  correspond  to  the
              internal  hash  table  of  commands  as  maintained  by the hhaasshh
              builtin.  Elements added to this array appear in the hash table;
              unsetting  array  elements cause commands to be removed from the
              hash table.
       BBAASSHH__CCOOMMMMAANNDD
              The command currently being executed or about  to  be  executed,
              unless the shell is executing a command as the result of a trap,
              in which case it is the command executing at  the  time  of  the
              trap.
       BBAASSHH__EEXXEECCUUTTIIOONN__SSTTRRIINNGG
              The command argument to the --cc invocation option.
       BBAASSHH__LLIINNEENNOO
              An  array  variable whose members are the line numbers in source
              files   corresponding    to    each    member    of    FFUUNNCCNNAAMMEE.
              $${{BBAASSHH__LLIINNEENNOO[[_$_i]]}}  is  the line number in the source file where
              $${{FFUUNNCCNNAAMMEE[[_$_i]]}} was called (or  $${{BBAASSHH__LLIINNEENNOO[[_$_i_-_1]]}}  if  refer-
              enced  within another shell function).  The corresponding source
              file name is $${{BBAASSHH__SSOOUURRCCEE[[_$_i]]}}.  Use LLIINNEENNOO to obtain the  cur-
              rent line number.
       BBAASSHH__RREEMMAATTCCHH
              An  array  variable  whose members are assigned by the ==~~ binary
              operator to the [[[[ conditional command.  The element with  index
              0  is  the  portion  of  the  string matching the entire regular
              expression.  The element with index _n  is  the  portion  of  the
              string matching the _nth parenthesized subexpression.  This vari-
              able is read-only.
       BBAASSHH__SSOOUURRCCEE
              An array variable whose members are the source filenames  corre-
              sponding to the elements in the FFUUNNCCNNAAMMEE array variable.
       BBAASSHH__SSUUBBSSHHEELLLL
              Incremented  by one each time a subshell or subshell environment
              is spawned.  The initial value is 0.
       BBAASSHH__VVEERRSSIINNFFOO
              A readonly array variable whose members hold version information
              for  this  instance  of  bbaasshh.  The values assigned to the array
              members are as follows:
              BBAASSHH__VVEERRSSIINNFFOO[[0]]        The major version number (the  _r_e_l_e_a_s_e).
              BBAASSHH__VVEERRSSIINNFFOO[[1]]        The  minor version number (the _v_e_r_s_i_o_n).
              BBAASSHH__VVEERRSSIINNFFOO[[2]]        The patch level.
              BBAASSHH__VVEERRSSIINNFFOO[[3]]        The build version.
              BBAASSHH__VVEERRSSIINNFFOO[[4]]        The release status (e.g., _b_e_t_a_1).
              BBAASSHH__VVEERRSSIINNFFOO[[5]]        The value of MMAACCHHTTYYPPEE.

       BBAASSHH__VVEERRSSIIOONN
              Expands to a string describing the version of this  instance  of
              bbaasshh.

       CCOOMMPP__CCWWOORRDD
              An  index  into $${{CCOOMMPP__WWOORRDDSS}} of the word containing the current
              cursor position.  This variable is available only in shell func-
              tions  invoked  by  the  programmable completion facilities (see
              PPrrooggrraammmmaabbllee CCoommpplleettiioonn below).

       CCOOMMPP__KKEEYY
              The key (or final key of a key sequence) used to invoke the cur-
              rent completion function.

       CCOOMMPP__LLIINNEE
              The  current  command  line.  This variable is available only in
              shell functions  and  external  commands  invoked  by  the  pro-
              grammable  completion  facilities  (see  PPrrooggrraammmmaabbllee CCoommpplleettiioonn
              below).

       CCOOMMPP__PPOOIINNTT
              The index of the current cursor position relative to the  begin-
              ning  of the current command.  If the current cursor position is
              at the end of the current command, the value of this variable is
              equal  to  $${{##CCOOMMPP__LLIINNEE}}.   This  variable  is available only in
              shell functions  and  external  commands  invoked  by  the  pro-
              grammable  completion  facilities  (see  PPrrooggrraammmmaabbllee CCoommpplleettiioonn
              below).

       CCOOMMPP__TTYYPPEE
              Set to an integer value corresponding to the type of  completion
              attempted  that  caused a completion function to be called: _T_A_B,
              for normal completion, _?, for listing completions after  succes-
              sive  tabs,  _!, for listing alternatives on partial word comple-
              tion, _@, to list completions if the word is not  unmodified,  or
              _%,  for  menu  completion.   This  variable is available only in
              shell functions  and  external  commands  invoked  by  the  pro-
              grammable  completion  facilities  (see  PPrrooggrraammmmaabbllee CCoommpplleettiioonn
              below).

       CCOOMMPP__WWOORRDDBBRREEAAKKSS
              The set of characters that the rreeaaddlliinnee library treats  as  word
              separators  when performing word completion.  If CCOOMMPP__WWOORRDDBBRREEAAKKSS
              is unset, it loses its special properties, even if it is  subse-
              quently reset.

       CCOOMMPP__WWOORRDDSS
              An  array variable (see AArrrraayyss below) consisting of the individ-
              ual words in the current command line.  The line is  split  into
              words  as  rreeaaddlliinnee  would  split  it,  using CCOOMMPP__WWOORRDDBBRREEAAKKSS as
              described above.  This variable is available only in shell func-
              tions  invoked  by  the  programmable completion facilities (see
              PPrrooggrraammmmaabbllee CCoommpplleettiioonn below).

       DDIIRRSSTTAACCKK
              An array variable (see AArrrraayyss below) containing the current con-
              tents  of  the directory stack.  Directories appear in the stack
              in the order they are displayed by the ddiirrss builtin.   Assigning
              to members of this array variable may be used to modify directo-
              ries already in the stack, but the ppuusshhdd and ppooppdd builtins  must
              be used to add and remove directories.  Assignment to this vari-
              able will not change the  current  directory.   If  DDIIRRSSTTAACCKK  is
              unset,  it  loses  its  special properties, even if it is subse-
              quently reset.

       EEUUIIDD   Expands to the effective user ID of the current  user,  initial-
              ized at shell startup.  This variable is readonly.

       FFUUNNCCNNAAMMEE
              An  array  variable  containing the names of all shell functions
              currently in the execution call stack.  The element with index 0
              is the name of any currently-executing shell function.  The bot-
              tom-most element is "main".  This variable exists  only  when  a
              shell  function  is  executing.  Assignments to FFUUNNCCNNAAMMEE have no
              effect and return an error status.  If  FFUUNNCCNNAAMMEE  is  unset,  it
              loses  its special properties, even if it is subsequently reset.

       GGRROOUUPPSS An array variable containing the list of  groups  of  which  the
              current  user is a member.  Assignments to GGRROOUUPPSS have no effect
              and return an error status.  If GGRROOUUPPSS is unset,  it  loses  its
              special properties, even if it is subsequently reset.

       HHIISSTTCCMMDD
              The history number, or index in the history list, of the current
              command.  If HHIISSTTCCMMDD is unset, it loses its special  properties,
              even if it is subsequently reset.

       HHOOSSTTNNAAMMEE
              Automatically set to the name of the current host.

       HHOOSSTTTTYYPPEE
              Automatically  set  to a string that uniquely describes the type
              of machine on which bbaasshh is executing.  The default  is  system-
              dependent.

       LLIINNEENNOO Each  time this parameter is referenced, the shell substitutes a
              decimal number representing the current sequential  line  number
              (starting  with  1)  within a script or function.  When not in a
              script or function, the value substituted is not  guaranteed  to
              be meaningful.  If LLIINNEENNOO is unset, it loses its special proper-
              ties, even if it is subsequently reset.

       MMAACCHHTTYYPPEE
              Automatically set to a string that fully  describes  the  system
              type  on  which  bbaasshh is executing, in the standard GNU _c_p_u_-_c_o_m_-
              _p_a_n_y_-_s_y_s_t_e_m format.  The default is system-dependent.

       OOLLDDPPWWDD The previous working directory as set by the ccdd command.

       OOPPTTAARRGG The value of the last option argument processed by  the  ggeettooppttss
              builtin command (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).

       OOPPTTIINNDD The  index  of  the next argument to be processed by the ggeettooppttss
              builtin command (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).

       OOSSTTYYPPEE Automatically set to a string that describes the operating  sys-
              tem  on  which  bbaasshh is executing.  The default is system-depen-
              dent.

       PPIIPPEESSTTAATTUUSS
              An array variable (see AArrrraayyss below) containing a list  of  exit
              status  values  from the processes in the most-recently-executed
              foreground pipeline (which may contain only a single command).

       PPPPIIDD   The process ID of the shell’s parent.  This  variable  is  read-
              only.

       PPWWDD    The current working directory as set by the ccdd command.

       RRAANNDDOOMM Each time this parameter is referenced, a random integer between
              0 and 32767 is generated.  The sequence of random numbers may be
              initialized by assigning a value to RRAANNDDOOMM.  If RRAANNDDOOMM is unset,
              it loses its special properties,  even  if  it  is  subsequently
              reset.

       RREEPPLLYY  Set  to  the line of input read by the rreeaadd builtin command when
              no arguments are supplied.

       SSEECCOONNDDSS
              Each time this parameter is referenced, the  number  of  seconds
              since  shell  invocation is returned.  If a value is assigned to
              SSEECCOONNDDSS, the value returned upon subsequent  references  is  the
              number  of seconds since the assignment plus the value assigned.
              If SSEECCOONNDDSS is unset, it loses its special properties, even if it
              is subsequently reset.

       SSHHEELLLLOOPPTTSS
              A  colon-separated  list of enabled shell options.  Each word in
              the list is a valid argument  for  the  --oo  option  to  the  sseett
              builtin command (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).  The options
              appearing in SSHHEELLLLOOPPTTSS are those reported as _o_n by sseett  --oo.   If
              this  variable  is  in the environment when bbaasshh starts up, each
              shell option in the list will  be  enabled  before  reading  any
              startup files.  This variable is read-only.

       SSHHLLVVLL  Incremented by one each time an instance of bbaasshh is started.

       UUIIDD    Expands to the user ID of the current user, initialized at shell
              startup.  This variable is readonly.

       The following variables are used by the shell.   In  some  cases,  bbaasshh
       assigns a default value to a variable; these cases are noted below.

       BBAASSHH__EENNVV
              If  this parameter is set when bbaasshh is executing a shell script,
              its value is interpreted as a filename  containing  commands  to
              initialize the shell, as in _~_/_._b_a_s_h_r_c.  The value of BBAASSHH__EENNVV is
              subjected to  parameter  expansion,  command  substitution,  and
              arithmetic  expansion  before  being interpreted as a file name.
              PPAATTHH is not used to search for the resultant file name.
       CCDDPPAATTHH The search path for the ccdd command.  This is  a  colon-separated
              list  of  directories  in  which the shell looks for destination
              directories specified by the ccdd  command.   A  sample  value  is
              ".:~:/usr".
       BBAASSHH__XXTTRRAACCEEFFDD
              If  set  to an integer corresponding to a valid file descriptor,
              bbaasshh will write the  trace  output  generated  when  _s_e_t  _-_x  is
              enabled  to that file descriptor.  The file descriptor is closed
              when BBAASSHH__XXTTRRAACCEEFFDD is unset or assigned a new value.   Unsetting
              BBAASSHH__XXTTRRAACCEEFFDD  or assigning it the empty string causes the trace
              output to be sent to the  standard  error.   Note  that  setting
              BBAASSHH__XXTTRRAACCEEFFDD to 2 (the standard error file descriptor) and then
              unsetting it will result in the standard error being closed.
       CCOOLLUUMMNNSS
              Used by the sseelleecctt builtin command  to  determine  the  terminal
              width  when  printing  selection  lists.  Automatically set upon
              receipt of a SIGWINCH.
       CCOOMMPPRREEPPLLYY
              An array variable from which bbaasshh reads the possible completions
              generated  by  a shell function invoked by the programmable com-
              pletion facility (see PPrrooggrraammmmaabbllee CCoommpplleettiioonn below).
       EEMMAACCSS  If bbaasshh finds this variable in the environment  when  the  shell
              starts  with  value "t", it assumes that the shell is running in
              an emacs shell buffer and disables line editing.
       FFCCEEDDIITT The default editor for the ffcc builtin command.
       FFIIGGNNOORREE
              A colon-separated list of suffixes  to  ignore  when  performing
              filename completion (see RREEAADDLLIINNEE below).  A filename whose suf-
              fix matches one of the entries in FFIIGGNNOORREE is excluded  from  the
              list of matched filenames.  A sample value is ".o:~".
       GGLLOOBBIIGGNNOORREE
              A colon-separated list of patterns defining the set of filenames
              to be ignored by pathname expansion.  If a filename matched by a
              pathname  expansion  pattern also matches one of the patterns in
              GGLLOOBBIIGGNNOORREE, it is removed from the list of matches.
       HHIISSTTCCOONNTTRROOLL
              A colon-separated list of values controlling  how  commands  are
              saved  on  the  history  list.   If  the list of values includes
              _i_g_n_o_r_e_s_p_a_c_e, lines which begin with a ssppaaccee  character  are  not
              saved  in  the history list.  A value of _i_g_n_o_r_e_d_u_p_s causes lines
              matching the previous history entry to not be saved.  A value of
              _i_g_n_o_r_e_b_o_t_h is shorthand for _i_g_n_o_r_e_s_p_a_c_e and _i_g_n_o_r_e_d_u_p_s.  A value
              of _e_r_a_s_e_d_u_p_s causes all previous lines matching the current line
              to  be  removed from the history list before that line is saved.
              Any value not in the above list is ignored.  If  HHIISSTTCCOONNTTRROOLL  is
              unset,  or does not include a valid value, all lines read by the
              shell parser are saved on the history list, subject to the value
              of  HHIISSTTIIGGNNOORREE.  The second and subsequent lines of a multi-line
              compound command are not tested, and are added  to  the  history
              regardless of the value of HHIISSTTCCOONNTTRROOLL.
       HHIISSTTFFIILLEE
              The name of the file in which command history is saved (see HHIISS--
              TTOORRYY below).  The default value is _~_/_._b_a_s_h___h_i_s_t_o_r_y.   If  unset,
              the  command  history  is  not  saved  when an interactive shell
              exits.
       HHIISSTTFFIILLEESSIIZZEE
              The maximum number of lines contained in the history file.  When
              this  variable  is  assigned  a value, the history file is trun-
              cated, if necessary, by removing the oldest entries, to  contain
              no  more  than  that number of lines.  The default value is 500.
              The history file is also truncated to this size after writing it
              when an interactive shell exits.
       HHIISSTTIIGGNNOORREE
              A  colon-separated list of patterns used to decide which command
              lines should be saved on the  history  list.   Each  pattern  is
              anchored  at  the  beginning of the line and must match the com-
              plete line (no implicit  ‘**’  is  appended).   Each  pattern  is
              tested  against  the line after the checks specified by HHIISSTTCCOONN--
              TTRROOLL are applied.  In  addition  to  the  normal  shell  pattern
              matching characters, ‘&&’ matches the previous history line.  ‘&&’
              may be escaped using  a  backslash;  the  backslash  is  removed
              before attempting a match.  The second and subsequent lines of a
              multi-line compound command are not tested, and are added to the
              history regardless of the value of HHIISSTTIIGGNNOORREE.
       HHIISSTTSSIIZZEE
              The  number  of commands to remember in the command history (see
              HHIISSTTOORRYY below).  The default value is 500.
       HHIISSTTTTIIMMEEFFOORRMMAATT
              If this variable is set and not null, its value  is  used  as  a
              format string for _s_t_r_f_t_i_m_e(3) to print the time stamp associated
              with each history entry displayed by the  hhiissttoorryy  builtin.   If
              this  variable  is  set,  time stamps are written to the history
              file so they may be preserved across shell sessions.  This  uses
              the  history  comment  character  to distinguish timestamps from
              other history lines.
       HHOOMMEE   The home directory of the current user; the default argument for
              the ccdd builtin command.  The value of this variable is also used
              when performing tilde expansion.
       HHOOSSTTFFIILLEE
              Contains the name of a file in the  same  format  as  _/_e_t_c_/_h_o_s_t_s
              that should be read when the shell needs to complete a hostname.
              The list of possible hostname completions may be  changed  while
              the  shell  is  running;  the  next  time hostname completion is
              attempted after the value is changed, bbaasshh adds the contents  of
              the  new file to the existing list.  If HHOOSSTTFFIILLEE is set, but has
              no value, or does not name a readable  file,  bbaasshh  attempts  to
              read  _/_e_t_c_/_h_o_s_t_s to obtain the list of possible hostname comple-
              tions.  When HHOOSSTTFFIILLEE is unset, the hostname list is cleared.
       IIFFSS    The _I_n_t_e_r_n_a_l _F_i_e_l_d _S_e_p_a_r_a_t_o_r that is  used  for  word  splitting
              after  expansion  and  to  split  lines into words with the rreeaadd
              builtin  command.   The  default  value  is  ‘‘<space><tab><new-
              line>’’.
       IIGGNNOORREEEEOOFF
              Controls the action of an interactive shell on receipt of an EEOOFF
              character as the sole input.  If set, the value is the number of
              consecutive  EEOOFF  characters  which  must  be typed as the first
              characters on an input line before bbaasshh exits.  If the  variable
              exists  but  does not have a numeric value, or has no value, the
              default value is 10.  If it does not exist,  EEOOFF  signifies  the
              end of input to the shell.
       IINNPPUUTTRRCC
              The  filename  for  the  rreeaaddlliinnee  startup  file, overriding the
              default of _~_/_._i_n_p_u_t_r_c (see RREEAADDLLIINNEE below).
       LLAANNGG   Used to determine the  locale  category  for  any  category  not
              specifically selected with a variable starting with LLCC__.
       LLCC__AALLLL This  variable  overrides  the  value  of LLAANNGG and any other LLCC__
              variable specifying a locale category.
       LLCC__CCOOLLLLAATTEE
              This variable determines the collation order used  when  sorting
              the  results  of pathname expansion, and determines the behavior
              of  range  expressions,  equivalence  classes,   and   collating
              sequences within pathname expansion and pattern matching.
       LLCC__CCTTYYPPEE
              This  variable  determines  the interpretation of characters and
              the behavior of character classes within pathname expansion  and
              pattern matching.
       LLCC__MMEESSSSAAGGEESS
              This  variable  determines  the locale used to translate double-
              quoted strings preceded by a $$.
       LLCC__NNUUMMEERRIICC
              This variable determines the locale  category  used  for  number
              formatting.
       LLIINNEESS  Used  by  the  sseelleecctt  builtin  command  to determine the column
              length for printing selection  lists.   Automatically  set  upon
              receipt of a SSIIGGWWIINNCCHH.
       MMAAIILL   If  this  parameter is set to a file name and the MMAAIILLPPAATTHH vari-
              able is not set, bbaasshh informs the user of the arrival of mail in
              the specified file.
       MMAAIILLCCHHEECCKK
              Specifies  how  often  (in  seconds)  bbaasshh checks for mail.  The
              default is 60 seconds.  When it is time to check for  mail,  the
              shell  does  so  before  displaying the primary prompt.  If this
              variable is unset, or set to  a  value  that  is  not  a  number
              greater than or equal to zero, the shell disables mail checking.
       MMAAIILLPPAATTHH
              A colon-separated list of file names to  be  checked  for  mail.
              The message to be printed when mail arrives in a particular file
              may be specified by separating the file name  from  the  message
              with a ‘?’.  When used in the text of the message, $$__ expands to
              the name of the current mailfile.  Example:
              MMAAIILLPPAATTHH='/var/mail/bfox?"You  have  mail":~/shell-mail?"$_  has
              mail!"'
              BBaasshh  supplies  a  default  value  for  this  variable,  but the
              location of the user mail files that it uses is system dependent
              (e.g., /var/mail/$$UUSSEERR).
       OOPPTTEERRRR If set to the value 1, bbaasshh displays error messages generated by
              the ggeettooppttss builtin command (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS  below).
              OOPPTTEERRRR  is  initialized to 1 each time the shell is invoked or a
              shell script is executed.
       PPAATTHH   The search path for commands.  It is a colon-separated  list  of
              directories  in  which the shell looks for commands (see CCOOMMMMAANNDD
              EEXXEECCUUTTIIOONN below).  A zero-length (null) directory  name  in  the
              value of PPAATTHH indicates the current directory.  A null directory
              name may appear as two adjacent colons,  or  as  an  initial  or
              trailing  colon.   The  default path is system-dependent, and is
              set by the administrator who installs bbaasshh.  A common  value  is
              ‘‘/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin’’.
       PPOOSSIIXXLLYY__CCOORRRREECCTT
              If  this  variable  is  in the environment when bbaasshh starts, the
              shell enters _p_o_s_i_x _m_o_d_e before reading the startup files, as  if
              the  ----ppoossiixx  invocation option had been supplied.  If it is set
              while the shell is running, bbaasshh enables _p_o_s_i_x _m_o_d_e, as  if  the
              command _s_e_t _-_o _p_o_s_i_x had been executed.
       PPRROOMMPPTT__CCOOMMMMAANNDD
              If set, the value is executed as a command prior to issuing each
              primary prompt.
       PPRROOMMPPTT__DDIIRRTTRRIIMM
              If set to a number greater than zero, the value is used  as  the
              number of trailing directory components to retain when expanding
              the \\ww and \\WW  prompt  string  escapes  (see  PPRROOMMPPTTIINNGG  below).
              Characters removed are replaced with an ellipsis.
       PPSS11    The  value  of  this parameter is expanded (see PPRROOMMPPTTIINNGG below)
              and used as the primary prompt string.   The  default  value  is
              ‘‘\\ss--\\vv\\$$ ’’.
       PPSS22    The  value of this parameter is expanded as with PPSS11 and used as
              the secondary prompt string.  The default is ‘‘>> ’’.
       PPSS33    The value of this parameter is used as the prompt for the sseelleecctt
              command (see SSHHEELLLL GGRRAAMMMMAARR above).
       PPSS44    The  value  of  this  parameter  is expanded as with PPSS11 and the
              value is printed before each command  bbaasshh  displays  during  an
              execution  trace.  The first character of PPSS44 is replicated mul-
              tiple times, as necessary, to indicate multiple levels of  indi-
              rection.  The default is ‘‘++ ’’.
       SSHHEELLLL  The full pathname to the shell is kept in this environment vari-
              able.  If it is not set when the shell starts, bbaasshh  assigns  to
              it the full pathname of the current user’s login shell.
       TTIIMMEEFFOORRMMAATT
              The  value of this parameter is used as a format string specify-
              ing how the timing information for pipelines prefixed  with  the
              ttiimmee  reserved word should be displayed.  The %% character intro-
              duces an escape sequence that is expanded to  a  time  value  or
              other  information.  The escape sequences and their meanings are
              as follows; the braces denote optional portions.
              %%%%        A literal %%.
              %%[[_p]][[ll]]RR  The elapsed time in seconds.
              %%[[_p]][[ll]]UU  The number of CPU seconds spent in user mode.
              %%[[_p]][[ll]]SS  The number of CPU seconds spent in system mode.
              %%PP        The CPU percentage, computed as (%U + %S) / %R.

              The optional _p is a digit specifying the _p_r_e_c_i_s_i_o_n,  the  number
              of fractional digits after a decimal point.  A value of 0 causes
              no decimal point or fraction to be output.  At most three places
              after  the  decimal  point may be specified; values of _p greater
              than 3 are changed to 3.  If _p is not specified, the value 3  is
              used.

              The  optional ll specifies a longer format, including minutes, of
              the form _M_Mm_S_S._F_Fs.  The value of _p determines  whether  or  not
              the fraction is included.

              If  this  variable  is not set, bbaasshh acts as if it had the value
              $$''\\nnrreeaall\\tt%%33llRR\\nnuusseerr\\tt%%33llUU\\nnssyyss%%33llSS''.  If the value is null,  no
              timing  information  is  displayed.  A trailing newline is added
              when the format string is displayed.

       TTMMOOUUTT  If set to a value greater than zero, TTMMOOUUTT  is  treated  as  the
              default  timeout  for  the  rreeaadd  builtin.   The  sseelleecctt command
              terminates if input does not arrive  after  TTMMOOUUTT  seconds  when
              input  is  coming from a terminal.  In an interactive shell, the
              value is interpreted as the number of seconds to wait for  input
              after issuing the primary prompt.  BBaasshh terminates after waiting
              for that number of seconds if input does not arrive.

       TTMMPPDDIIRR If set, BBaasshh uses its value as the name of a directory in  which
              BBaasshh creates temporary files for the shell’s use.

       aauuttoo__rreessuummee
              This variable controls how the shell interacts with the user and
              job control.  If this variable is set, single word  simple  com-
              mands without redirections are treated as candidates for resump-
              tion of an existing stopped job.  There is no ambiguity allowed;
              if  there  is more than one job beginning with the string typed,
              the job most recently accessed  is  selected.   The  _n_a_m_e  of  a
              stopped  job, in this context, is the command line used to start
              it.  If set to the value _e_x_a_c_t, the string supplied  must  match
              the  name  of  a  stopped  job exactly; if set to _s_u_b_s_t_r_i_n_g, the
              string supplied needs to match a substring  of  the  name  of  a
              stopped  job.  The _s_u_b_s_t_r_i_n_g value provides functionality analo-
              gous to the %%??  job identifier (see JJOOBB CCOONNTTRROOLL below).  If  set
              to  any  other  value, the supplied string must be a prefix of a
              stopped job’s name; this provides functionality analogous to the
              %%_s_t_r_i_n_g job identifier.

       hhiissttcchhaarrss
              The  two or three characters which control history expansion and
              tokenization (see HHIISSTTOORRYY EEXXPPAANNSSIIOONN below).  The first character
              is  the _h_i_s_t_o_r_y _e_x_p_a_n_s_i_o_n character, the character which signals
              the start of a history  expansion,  normally  ‘!!’.   The  second
              character  is the _q_u_i_c_k _s_u_b_s_t_i_t_u_t_i_o_n character, which is used as
              shorthand for re-running the previous command  entered,  substi-
              tuting  one  string  for another in the command.  The default is
              ‘^^’.  The optional third character is the character which  indi-
              cates  that the remainder of the line is a comment when found as
              the first character of a word, normally ‘##’.  The  history  com-
              ment character causes history substitution to be skipped for the
              remaining words on the line.  It does not necessarily cause  the
              shell parser to treat the rest of the line as a comment.

   AArrrraayyss
       BBaasshh  provides one-dimensional indexed and associative array variables.
       Any variable may be used as an indexed array; the ddeeccllaarree builtin  will
       explicitly  declare an array.  There is no maximum limit on the size of
       an array, nor any requirement that members be indexed or assigned  con-
       tiguously.   Indexed  arrays  are  referenced using integers (including
       arithmetic expressions)  and are  zero-based;  associative  arrays  are
       referenced using arbitrary strings.

       An  indexed  array is created automatically if any variable is assigned
       to using the syntax _n_a_m_e[_s_u_b_s_c_r_i_p_t]=_v_a_l_u_e.  The _s_u_b_s_c_r_i_p_t is treated as
       an arithmetic expression that must evaluate to a number greater than or
       equal to zero.  To explicitly declare an indexed array, use ddeeccllaarree  --aa
       _n_a_m_e (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).  ddeeccllaarree --aa _n_a_m_e[[_s_u_b_s_c_r_i_p_t]] is
       also accepted; the _s_u_b_s_c_r_i_p_t is ignored.

       Associative arrays are created using ddeeccllaarree --AA _n_a_m_e.

       Attributes may be specified for an array variable using the ddeeccllaarree and
       rreeaaddoonnllyy  builtins.  Each attribute applies to all members of an array.

       Arrays  are  assigned  to  using  compound  assignments  of  the   form
       _n_a_m_e=((value_1  ...  value_n)),  where  each  _v_a_l_u_e  is  of  the form [_s_u_b_-
       _s_c_r_i_p_t]=_s_t_r_i_n_g.  Indexed array assignments do not require  the  bracket
       and  subscript.   When  assigning  to  indexed  arrays, if the optional
       brackets and subscript are supplied, that index is assigned to;  other-
       wise the index of the element assigned is the last index assigned to by
       the statement plus one.  Indexing starts at zero.

       When assigning to an associative array, the subscript is required.

       This syntax is also accepted by the ddeeccllaarree builtin.  Individual  array
       elements  may  be  assigned  to  using the _n_a_m_e[_s_u_b_s_c_r_i_p_t]=_v_a_l_u_e syntax
       introduced above.

       Any element of an array may  be  referenced  using  ${_n_a_m_e[_s_u_b_s_c_r_i_p_t]}.
       The braces are required to avoid conflicts with pathname expansion.  If
       _s_u_b_s_c_r_i_p_t is @@ or **, the word expands to all members  of  _n_a_m_e.   These
       subscripts  differ only when the word appears within double quotes.  If
       the word is double-quoted, ${_n_a_m_e[*]} expands to a single word with the
       value  of each array member separated by the first character of the IIFFSS
       special variable, and ${_n_a_m_e[@]} expands each element of _n_a_m_e to a sep-
       arate  word.   When  there  are no array members, ${_n_a_m_e[@]} expands to
       nothing.  If the double-quoted expansion  occurs  within  a  word,  the
       expansion  of  the first parameter is joined with the beginning part of
       the original word, and the expansion of the last  parameter  is  joined
       with  the  last  part  of  the original word.  This is analogous to the
       expansion of the special parameters ** and  @@  (see  SSppeecciiaall  PPaarraammeetteerrss
       above).   ${#_n_a_m_e[_s_u_b_s_c_r_i_p_t]}  expands  to  the  length  of ${_n_a_m_e[_s_u_b_-
       _s_c_r_i_p_t]}.  If _s_u_b_s_c_r_i_p_t is ** or @@, the expansion is the number of  ele-
       ments  in the array.  Referencing an array variable without a subscript
       is equivalent to referencing the array with a subscript of 0.

       An array variable is considered set if a subscript has been assigned  a
       value.  The null string is a valid value.

       The  uunnsseett  builtin  is  used to destroy arrays.  uunnsseett _n_a_m_e[_s_u_b_s_c_r_i_p_t]
       destroys the array element at index _s_u_b_s_c_r_i_p_t.  Care must be  taken  to
       avoid  unwanted side effects caused by pathname expansion.  uunnsseett _n_a_m_e,
       where _n_a_m_e is an array, or uunnsseett _n_a_m_e[_s_u_b_s_c_r_i_p_t], where _s_u_b_s_c_r_i_p_t is  **
       or @@, removes the entire array.

       The  ddeeccllaarree,  llooccaall,  and rreeaaddoonnllyy builtins each accept a --aa option to
       specify an indexed array and a --AA  option  to  specify  an  associative
       array.   The rreeaadd builtin accepts a --aa option to assign a list of words
       read from the standard input to an array.  The sseett and ddeeccllaarree builtins
       display  array values in a way that allows them to be reused as assign-
       ments.

EEXXPPAANNSSIIOONN
       Expansion is performed on the command line after it has been split into
       words.   There are seven kinds of expansion performed: _b_r_a_c_e _e_x_p_a_n_s_i_o_n,
       _t_i_l_d_e _e_x_p_a_n_s_i_o_n, _p_a_r_a_m_e_t_e_r _a_n_d _v_a_r_i_a_b_l_e  _e_x_p_a_n_s_i_o_n,  _c_o_m_m_a_n_d  _s_u_b_s_t_i_t_u_-
       _t_i_o_n, _a_r_i_t_h_m_e_t_i_c _e_x_p_a_n_s_i_o_n, _w_o_r_d _s_p_l_i_t_t_i_n_g, and _p_a_t_h_n_a_m_e _e_x_p_a_n_s_i_o_n.

       The  order  of expansions is: brace expansion, tilde expansion, parame-
       ter, variable and arithmetic expansion and command  substitution  (done
       in a left-to-right fashion), word splitting, and pathname expansion.

       On systems that can support it, there is an additional expansion avail-
       able: _p_r_o_c_e_s_s _s_u_b_s_t_i_t_u_t_i_o_n.

       Only brace expansion, word splitting, and pathname expansion can change
       the  number of words of the expansion; other expansions expand a single
       word to a single word.  The only exceptions to this are the  expansions
       of "$$@@" and "$${{_n_a_m_e[[@@]]}}" as explained above (see PPAARRAAMMEETTEERRSS).

   BBrraaccee EExxppaannssiioonn
       _B_r_a_c_e _e_x_p_a_n_s_i_o_n is a mechanism by which arbitrary strings may be gener-
       ated.  This mechanism is similar to _p_a_t_h_n_a_m_e _e_x_p_a_n_s_i_o_n, but  the  file-
       names generated need not exist.  Patterns to be brace expanded take the
       form of an optional _p_r_e_a_m_b_l_e, followed by either a series of comma-sep-
       arated  strings or a sequence expression between a pair of braces, fol-
       lowed by an optional _p_o_s_t_s_c_r_i_p_t.  The  preamble  is  prefixed  to  each
       string contained within the braces, and the postscript is then appended
       to each resulting string, expanding left to right.

       Brace expansions may be nested.  The results of  each  expanded  string
       are  not  sorted;  left  to  right  order  is  preserved.  For example,
       a{{d,c,b}}e expands into ‘ade ace abe’.

       A sequence expression takes the form {{_x...._y[[...._i_n_c_r]]}}, where _x and _y  are
       either  integers or single characters, and _i_n_c_r, an optional increment,
       is an integer.  When integers are supplied, the expression  expands  to
       each  number between _x and _y, inclusive.  Supplied integers may be pre-
       fixed with _0 to force each term to have the same width.  When either  _x
       or  _y  begins  with  a  zero, the shell attempts to force all generated
       terms to contain the same number of digits, zero-padding  where  neces-
       sary.   When  characters  are  supplied, the expression expands to each
       character lexicographically between _x and _y, inclusive.  Note that both
       _x  and  _y must be of the same type.  When the increment is supplied, it
       is used as the difference between each term.  The default increment  is
       1 or -1 as appropriate.

       Brace expansion is performed before any other expansions, and any char-
       acters special to other expansions are preserved in the result.  It  is
       strictly  textual.  BBaasshh does not apply any syntactic interpretation to
       the context of the expansion or the text between the braces.

       A correctly-formed brace expansion must contain  unquoted  opening  and
       closing  braces,  and  at  least one unquoted comma or a valid sequence
       expression.  Any incorrectly formed brace expansion is left  unchanged.
       A {{ or ,, may be quoted with a backslash to prevent its being considered
       part of a brace expression.  To avoid conflicts with  parameter  expan-
       sion, the string $${{ is not considered eligible for brace expansion.

       This construct is typically used as shorthand when the common prefix of
       the strings to be generated is longer than in the above example:

              mkdir /usr/local/src/bash/{old,new,dist,bugs}
       or
              chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}

       Brace expansion introduces a  slight  incompatibility  with  historical
       versions  of sshh.  sshh does not treat opening or closing braces specially
       when they appear as part of a word, and preserves them in  the  output.
       BBaasshh  removes  braces  from  words as a consequence of brace expansion.
       For example, a word entered to sshh as _f_i_l_e_{_1_,_2_} appears  identically  in
       the  output.  The same word is output as _f_i_l_e_1 _f_i_l_e_2 after expansion by
       bbaasshh.  If strict compatibility with sshh is desired, start bbaasshh with  the
       ++BB option or disable brace expansion with the ++BB option to the sseett com-
       mand (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).

   TTiillddee EExxppaannssiioonn
       If a word begins with an unquoted tilde character  (‘~~’),  all  of  the
       characters  preceding  the  first unquoted slash (or all characters, if
       there is no unquoted slash) are considered a _t_i_l_d_e_-_p_r_e_f_i_x.  If none  of
       the  characters  in  the tilde-prefix are quoted, the characters in the
       tilde-prefix following the tilde are treated as a possible _l_o_g_i_n  _n_a_m_e.
       If  this  login name is the null string, the tilde is replaced with the
       value of the shell parameter HHOOMMEE.  If HHOOMMEE is unset, the  home  direc-
       tory  of  the  user executing the shell is substituted instead.  Other-
       wise, the tilde-prefix is replaced with the home  directory  associated
       with the specified login name.

       If  the  tilde-prefix  is  a  ‘~+’, the value of the shell variable PPWWDD
       replaces the tilde-prefix.  If the tilde-prefix is a ‘~-’, the value of
       the  shell variable OOLLDDPPWWDD, if it is set, is substituted.  If the char-
       acters following the tilde in the tilde-prefix consist of a  number  _N,
       optionally  prefixed  by  a  ‘+’ or a ‘-’, the tilde-prefix is replaced
       with the corresponding element from the directory stack, as it would be
       displayed by the ddiirrss builtin invoked with the tilde-prefix as an argu-
       ment.  If the characters following the tilde in the  tilde-prefix  con-
       sist of a number without a leading ‘+’ or ‘-’, ‘+’ is assumed.

       If the login name is invalid, or the tilde expansion fails, the word is
       unchanged.

       Each variable assignment is checked for unquoted tilde-prefixes immedi-
       ately following a :: or the first ==.  In these cases, tilde expansion is
       also performed.  Consequently, one may use file names  with  tildes  in
       assignments  to  PPAATTHH,  MMAAIILLPPAATTHH, and CCDDPPAATTHH, and the shell assigns the
       expanded value.

   PPaarraammeetteerr EExxppaannssiioonn
       The ‘$$’ character introduces parameter expansion, command substitution,
       or  arithmetic  expansion.  The parameter name or symbol to be expanded
       may be enclosed in braces, which are optional but serve to protect  the
       variable  to be expanded from characters immediately following it which
       could be interpreted as part of the name.

       When braces are used, the matching ending brace is the  first  ‘}}’  not
       escaped  by  a  backslash  or within a quoted string, and not within an
       embedded  arithmetic  expansion,  command  substitution,  or  parameter
       expansion.

       ${_p_a_r_a_m_e_t_e_r}
              The  value of _p_a_r_a_m_e_t_e_r is substituted.  The braces are required
              when _p_a_r_a_m_e_t_e_r is a positional  parameter  with  more  than  one
              digit, or when _p_a_r_a_m_e_t_e_r is followed by a character which is not
              to be interpreted as part of its name.

       If the first character of _p_a_r_a_m_e_t_e_r is  an  exclamation  point  (!!),  a
       level  of  variable  indirection is introduced.  BBaasshh uses the value of
       the variable formed from the rest of _p_a_r_a_m_e_t_e_r as the name of the vari-
       able; this variable is then expanded and that value is used in the rest
       of the substitution, rather than the value of _p_a_r_a_m_e_t_e_r  itself.   This
       is  known as _i_n_d_i_r_e_c_t _e_x_p_a_n_s_i_o_n.  The exceptions to this are the expan-
       sions of ${!_p_r_e_f_i_x*} and ${!!_n_a_m_e[_@]} described below.  The  exclamation
       point  must  immediately  follow  the  left brace in order to introduce
       indirection.

       In each of the cases below, _w_o_r_d is subject to tilde expansion, parame-
       ter expansion, command substitution, and arithmetic expansion.

       When  not  performing  substring  expansion, using the forms documented
       below, bbaasshh tests for a parameter that is unset or null.  Omitting  the
       colon results in a test only for a parameter that is unset.

       ${_p_a_r_a_m_e_t_e_r::--_w_o_r_d}
              UUssee  DDeeffaauulltt  VVaalluueess.  If _p_a_r_a_m_e_t_e_r is unset or null, the expan-
              sion of _w_o_r_d is substituted.  Otherwise, the value of  _p_a_r_a_m_e_t_e_r
              is substituted.
       ${_p_a_r_a_m_e_t_e_r::==_w_o_r_d}
              AAssssiiggnn  DDeeffaauulltt  VVaalluueess.   If  _p_a_r_a_m_e_t_e_r  is  unset or null, the
              expansion of _w_o_r_d is assigned to _p_a_r_a_m_e_t_e_r.  The value of _p_a_r_a_m_-
              _e_t_e_r  is  then  substituted.   Positional parameters and special
              parameters may not be assigned to in this way.
       ${_p_a_r_a_m_e_t_e_r::??_w_o_r_d}
              DDiissppllaayy EErrrroorr iiff NNuullll oorr UUnnsseett.  If _p_a_r_a_m_e_t_e_r is null or  unset,
              the  expansion  of  _w_o_r_d (or a message to that effect if _w_o_r_d is
              not present) is written to the standard error and the shell,  if
              it is not interactive, exits.  Otherwise, the value of _p_a_r_a_m_e_t_e_r
              is substituted.
       ${_p_a_r_a_m_e_t_e_r::++_w_o_r_d}
              UUssee AAlltteerrnnaattee VVaalluuee.  If _p_a_r_a_m_e_t_e_r is null or unset, nothing  is
              substituted, otherwise the expansion of _w_o_r_d is substituted.
       ${_p_a_r_a_m_e_t_e_r::_o_f_f_s_e_t}
       ${_p_a_r_a_m_e_t_e_r::_o_f_f_s_e_t::_l_e_n_g_t_h}
              SSuubbssttrriinngg  EExxppaannssiioonn..   Expands  to  up  to _l_e_n_g_t_h characters of
              _p_a_r_a_m_e_t_e_r starting at the character  specified  by  _o_f_f_s_e_t.   If
              _l_e_n_g_t_h  is omitted, expands to the substring of _p_a_r_a_m_e_t_e_r start-
              ing at the character specified by _o_f_f_s_e_t.  _l_e_n_g_t_h and _o_f_f_s_e_t are
              arithmetic   expressions   (see  AARRIITTHHMMEETTIICC  EEVVAALLUUAATTIIOONN  below).
              _l_e_n_g_t_h must evaluate to a number greater than or equal to  zero.
              If  _o_f_f_s_e_t  evaluates  to  a number less than zero, the value is
              used as an offset from the end of the value  of  _p_a_r_a_m_e_t_e_r.   If
              _p_a_r_a_m_e_t_e_r  is  @@,  the  result  is  _l_e_n_g_t_h positional parameters
              beginning at _o_f_f_s_e_t.  If _p_a_r_a_m_e_t_e_r is an indexed array name sub-
              scripted  by  @  or  *,  the result is the _l_e_n_g_t_h members of the
              array beginning with ${_p_a_r_a_m_e_t_e_r[_o_f_f_s_e_t]}.  A negative _o_f_f_s_e_t is
              taken  relative  to  one  greater  than the maximum index of the
              specified array.  Substring expansion applied to an  associative
              array  produces  undefined results.  Note that a negative offset
              must be separated from the colon by at least one space to  avoid
              being  confused  with  the  :- expansion.  Substring indexing is
              zero-based unless the positional parameters are used,  in  which
              case  the  indexing starts at 1 by default.  If _o_f_f_s_e_t is 0, and
              the positional parameters are used, $$00 is prefixed to the  list.

       ${!!_p_r_e_f_i_x**}
       ${!!_p_r_e_f_i_x@@}
              NNaammeess  mmaattcchhiinngg pprreeffiixx..  Expands to the names of variables whose
              names begin with _p_r_e_f_i_x, separated by the first character of the
              IIFFSS  special variable.  When _@ is used and the expansion appears
              within double quotes, each variable name expands to  a  separate
              word.

       ${!!_n_a_m_e[_@]}
       ${!!_n_a_m_e[_*]}
              LLiisstt  ooff  aarrrraayy  kkeeyyss..  If _n_a_m_e is an array variable, expands to
              the list of array indices (keys) assigned in _n_a_m_e.  If  _n_a_m_e  is
              not  an  array,  expands to 0 if _n_a_m_e is set and null otherwise.
              When _@ is used and the expansion appears within  double  quotes,
              each key expands to a separate word.

       ${##_p_a_r_a_m_e_t_e_r}
              PPaarraammeetteerr  lleennggtthh..   The  length  in  characters of the value of
              _p_a_r_a_m_e_t_e_r is substituted.  If _p_a_r_a_m_e_t_e_r is **  or  @@,  the  value
              substituted  is the number of positional parameters.  If _p_a_r_a_m_e_-
              _t_e_r is an array name subscripted by ** or @@,  the  value  substi-
              tuted is the number of elements in the array.

       ${_p_a_r_a_m_e_t_e_r##_w_o_r_d}
       ${_p_a_r_a_m_e_t_e_r####_w_o_r_d}
              RReemmoovvee mmaattcchhiinngg pprreeffiixx ppaatttteerrnn..  The _w_o_r_d is expanded to produce
              a pattern just as in pathname expansion.  If the pattern matches
              the  beginning of the value of _p_a_r_a_m_e_t_e_r, then the result of the
              expansion is the expanded value of _p_a_r_a_m_e_t_e_r with  the  shortest
              matching  pattern  (the ‘‘##’’ case) or the longest matching pat-
              tern (the ‘‘####’’ case) deleted.  If _p_a_r_a_m_e_t_e_r is  @@  or  **,  the
              pattern  removal operation is applied to each positional parame-
              ter in turn, and the expansion is the resultant list.  If _p_a_r_a_m_-
              _e_t_e_r  is  an array variable subscripted with @@ or **, the pattern
              removal operation is applied to each  member  of  the  array  in
              turn, and the expansion is the resultant list.

       ${_p_a_r_a_m_e_t_e_r%%_w_o_r_d}
       ${_p_a_r_a_m_e_t_e_r%%%%_w_o_r_d}
              RReemmoovvee mmaattcchhiinngg ssuuffffiixx ppaatttteerrnn..  The _w_o_r_d is expanded to produce
              a pattern just as in pathname expansion.  If the pattern matches
              a  trailing portion of the expanded value of _p_a_r_a_m_e_t_e_r, then the
              result of the expansion is the expanded value of _p_a_r_a_m_e_t_e_r  with
              the  shortest  matching  pattern (the ‘‘%%’’ case) or the longest
              matching pattern (the ‘‘%%%%’’ case) deleted.  If _p_a_r_a_m_e_t_e_r  is  @@
              or  **,  the  pattern  removal operation is applied to each posi-
              tional parameter in turn, and the  expansion  is  the  resultant
              list.   If  _p_a_r_a_m_e_t_e_r is an array variable subscripted with @@ or
              **, the pattern removal operation is applied to  each  member  of
              the array in turn, and the expansion is the resultant list.

       ${_p_a_r_a_m_e_t_e_r//_p_a_t_t_e_r_n//_s_t_r_i_n_g}
              PPaatttteerrnn ssuubbssttiittuuttiioonn..  The _p_a_t_t_e_r_n is expanded to produce a pat-
              tern just as in pathname expansion.  _P_a_r_a_m_e_t_e_r is  expanded  and
              the  longest match of _p_a_t_t_e_r_n against its value is replaced with
              _s_t_r_i_n_g.  If _p_a_t_t_e_r_n begins with //, all matches  of  _p_a_t_t_e_r_n  are
              replaced   with  _s_t_r_i_n_g.   Normally  only  the  first  match  is
              replaced.  If _p_a_t_t_e_r_n begins with ##, it must match at the begin-
              ning of the expanded value of _p_a_r_a_m_e_t_e_r.  If _p_a_t_t_e_r_n begins with
              %%, it must match at the end of the expanded value of  _p_a_r_a_m_e_t_e_r.
              If _s_t_r_i_n_g is null, matches of _p_a_t_t_e_r_n are deleted and the // fol-
              lowing _p_a_t_t_e_r_n may be omitted.  If _p_a_r_a_m_e_t_e_r is @@ or **, the sub-
              stitution  operation  is applied to each positional parameter in
              turn, and the expansion is the resultant list.  If _p_a_r_a_m_e_t_e_r  is
              an  array  variable  subscripted  with  @@ or **, the substitution
              operation is applied to each member of the array  in  turn,  and
              the expansion is the resultant list.

       ${_p_a_r_a_m_e_t_e_r^^_p_a_t_t_e_r_n}
       ${_p_a_r_a_m_e_t_e_r^^^^_p_a_t_t_e_r_n}
       ${_p_a_r_a_m_e_t_e_r,,_p_a_t_t_e_r_n}
       ${_p_a_r_a_m_e_t_e_r,,,,_p_a_t_t_e_r_n}
              CCaassee  mmooddiiffiiccaattiioonn..   This expansion modifies the case of alpha-
              betic characters in _p_a_r_a_m_e_t_e_r.  The _p_a_t_t_e_r_n is expanded to  pro-
              duce  a  pattern  just as in pathname expansion.  The ^^ operator
              converts lowercase letters matching _p_a_t_t_e_r_n to uppercase; the  ,,
              operator  converts matching uppercase letters to lowercase.  The
              ^^^^ and ,,,, expansions  convert  each  matched  character  in  the
              expanded  value;  the  ^^ and ,, expansions match and convert only
              the first character in the expanded value..  If _p_a_t_t_e_r_n is omit-
              ted,  it is treated like a ??, which matches every character.  If
              _p_a_r_a_m_e_t_e_r is @@ or **, the case modification operation is  applied
              to  each  positional parameter in turn, and the expansion is the
              resultant list.  If _p_a_r_a_m_e_t_e_r is an array  variable  subscripted
              with  @@ or **, the case modification operation is applied to each
              member of the array in turn, and the expansion is the  resultant
              list.

   CCoommmmaanndd SSuubbssttiittuuttiioonn
       _C_o_m_m_a_n_d _s_u_b_s_t_i_t_u_t_i_o_n allows the output of a command to replace the com-
       mand name.  There are two forms:


              $$((_c_o_m_m_a_n_d))
       or
              ``_c_o_m_m_a_n_d``

       BBaasshh performs the expansion by executing _c_o_m_m_a_n_d and replacing the com-
       mand  substitution  with  the  standard output of the command, with any
       trailing newlines deleted.  Embedded newlines are not deleted, but they
       may  be  removed during word splitting.  The command substitution $$((ccaatt
       _f_i_l_e)) can be replaced by the equivalent but faster $$((<< _f_i_l_e)).

       When the old-style backquote form of substitution  is  used,  backslash
       retains  its  literal  meaning except when followed by $$, ``, or \\.  The
       first backquote not preceded by a backslash terminates the command sub-
       stitution.   When using the $(_c_o_m_m_a_n_d) form, all characters between the
       parentheses make up the command; none are treated specially.

       Command substitutions may be nested.  To nest when using the backquoted
       form, escape the inner backquotes with backslashes.

       If  the  substitution  appears within double quotes, word splitting and
       pathname expansion are not performed on the results.

   AArriitthhmmeettiicc EExxppaannssiioonn
       Arithmetic expansion allows the evaluation of an arithmetic  expression
       and  the  substitution of the result.  The format for arithmetic expan-
       sion is:

              $$((((_e_x_p_r_e_s_s_i_o_n))))

       The _e_x_p_r_e_s_s_i_o_n is treated as if it were within  double  quotes,  but  a
       double  quote  inside  the  parentheses  is not treated specially.  All
       tokens in the expression undergo parameter expansion, string expansion,
       command  substitution, and quote removal.  Arithmetic expansions may be
       nested.

       The evaluation is performed according to the rules listed  below  under
       AARRIITTHHMMEETTIICC EEVVAALLUUAATTIIOONN.  If _e_x_p_r_e_s_s_i_o_n is invalid, bbaasshh prints a message
       indicating failure and no substitution occurs.

   PPrroocceessss SSuubbssttiittuuttiioonn
       _P_r_o_c_e_s_s _s_u_b_s_t_i_t_u_t_i_o_n is supported on systems that support  named  pipes
       (_F_I_F_O_s)  or the //ddeevv//ffdd method of naming open files.  It takes the form
       of <<((_l_i_s_t)) or >>((_l_i_s_t)).  The process _l_i_s_t is run with its input or  out-
       put connected to a _F_I_F_O or some file in //ddeevv//ffdd.  The name of this file
       is passed as an argument to the current command as the  result  of  the
       expansion.   If the >>((_l_i_s_t)) form is used, writing to the file will pro-
       vide input for _l_i_s_t.  If the <<((_l_i_s_t)) form is used, the file  passed  as
       an argument should be read to obtain the output of _l_i_s_t.

       When  available,  process substitution is performed simultaneously with
       parameter and variable expansion, command substitution, and  arithmetic
       expansion.

   WWoorrdd SSpplliittttiinngg
       The  shell  scans the results of parameter expansion, command substitu-
       tion, and arithmetic expansion that did not occur within double  quotes
       for _w_o_r_d _s_p_l_i_t_t_i_n_g.

       The  shell  treats each character of IIFFSS as a delimiter, and splits the
       results of the other expansions into words on these characters.  If IIFFSS
       is  unset,  or its value is exactly <<ssppaaccee>><<ttaabb>><<nneewwlliinnee>>, the default,
       then sequences of <<ssppaaccee>>, <<ttaabb>>, and <<nneewwlliinnee>> at  the  beginning  and
       end  of  the  results  of  the previous expansions are ignored, and any
       sequence of IIFFSS characters not  at  the  beginning  or  end  serves  to
       delimit  words.   If  IIFFSS  has  a  value  other  than the default, then
       sequences of the whitespace characters ssppaaccee and ttaabb are ignored at the
       beginning  and  end of the word, as long as the whitespace character is
       in the value of IIFFSS (an IIFFSS whitespace character).   Any  character  in
       IIFFSS  that is not IIFFSS whitespace, along with any adjacent IIFFSS whitespace
       characters, delimits a field.  A sequence of IIFFSS whitespace  characters
       is  also  treated as a delimiter.  If the value of IIFFSS is null, no word
       splitting occurs.

       Explicit null arguments ("""" or '''')  are  retained.   Unquoted  implicit
       null arguments, resulting from the expansion of parameters that have no
       values, are removed.  If a parameter with no value is  expanded  within
       double quotes, a null argument results and is retained.

       Note that if no expansion occurs, no splitting is performed.

   PPaatthhnnaammee EExxppaannssiioonn
       After  word  splitting,  unless  the --ff option has been set, bbaasshh scans
       each word for the characters **, ??, and [[.  If one of  these  characters
       appears,  then  the word is regarded as a _p_a_t_t_e_r_n, and replaced with an
       alphabetically sorted list of file names matching the pattern.   If  no
       matching  file  names  are  found, and the shell option nnuullllgglloobb is not
       enabled, the word is left unchanged.  If the nnuullllgglloobb  option  is  set,
       and  no  matches are found, the word is removed.  If the ffaaiillgglloobb shell
       option is set, and no matches are found, an error  message  is  printed
       and  the  command  is  not executed.  If the shell option nnooccaasseegglloobb is
       enabled, the match is performed without regard to the  case  of  alpha-
       betic  characters.   When a pattern is used for pathname expansion, the
       character ‘‘‘‘..’’’’  at the start of a  name  or  immediately  following  a
       slash  must  be  matched explicitly, unless the shell option ddoottgglloobb is
       set.  When matching a pathname, the  slash  character  must  always  be
       matched  explicitly.   In  other  cases,  the  ‘‘‘‘..’’’’   character is not
       treated specially.  See the description  of  sshhoopptt  below  under  SSHHEELLLL
       BBUUIILLTTIINN  CCOOMMMMAANNDDSS  for a description of the nnooccaasseegglloobb, nnuullllgglloobb, ffaaiill--
       gglloobb, and ddoottgglloobb shell options.

       The GGLLOOBBIIGGNNOORREE shell variable may be used to restrict the set  of  file
       names  matching  a  _p_a_t_t_e_r_n.   If GGLLOOBBIIGGNNOORREE is set, each matching file
       name that also matches one of the patterns  in  GGLLOOBBIIGGNNOORREE  is  removed
       from the list of matches.  The file names ‘‘‘‘..’’’’  and ‘‘‘‘....’’’’  are always
       ignored when GGLLOOBBIIGGNNOORREE is set and not null.  However, setting  GGLLOOBBIIGG--
       NNOORREE  to  a non-null value has the effect of enabling the ddoottgglloobb shell
       option, so all other file names beginning with a ‘‘‘‘..’’’’  will match.  To
       get  the  old  behavior  of ignoring file names beginning with a ‘‘‘‘..’’’’,
       make ‘‘‘‘..**’’’’  one of the patterns in GGLLOOBBIIGGNNOORREE.  The ddoottgglloobb option  is
       disabled when GGLLOOBBIIGGNNOORREE is unset.

       PPaatttteerrnn MMaattcchhiinngg

       Any character that appears in a pattern, other than the special pattern
       characters described below, matches itself.  The NUL character may  not
       occur  in  a pattern.  A backslash escapes the following character; the
       escaping backslash is discarded when  matching.   The  special  pattern
       characters must be quoted if they are to be matched literally.

       The special pattern characters have the following meanings:

       **      Matches  any  string, including the null string.  When the gglloobb--
              ssttaarr shell option is enabled, and ** is used in a pathname expan-
              sion  context,  two  adjacent  **s  used as a single pattern will
              match all files and zero or more directories and subdirectories.
              If  followed by a //, two adjacent **s will match only directories
              and subdirectories.
       ??      Matches any single character.
       [[......]]  Matches any one of the enclosed characters.  A pair  of  charac-
              ters separated by a hyphen denotes a _r_a_n_g_e _e_x_p_r_e_s_s_i_o_n; any char-
              acter that sorts between those two characters, inclusive,  using
              the  current  locale’s  collating sequence and character set, is
              matched.  If the first character following the [[ is a !!  or a  ^^
              then  any  character not enclosed is matched.  The sorting order
              of characters in range expressions is determined by the  current
              locale  and  the value of the LLCC__CCOOLLLLAATTEE shell variable, if set.
              A -- may be matched by including it as the first or last  charac-
              ter in the set.  A ]] may be matched by including it as the first
              character in the set.

              Within [[ and ]], _c_h_a_r_a_c_t_e_r _c_l_a_s_s_e_s can  be  specified  using  the
              syntax  [[::_c_l_a_s_s::]],  where  _c_l_a_s_s is one of the following classes
              defined in the POSIX standard:
              aallnnuumm aallpphhaa aasscciiii bbllaannkk ccnnttrrll  ddiiggiitt  ggrraapphh  lloowweerr  pprriinntt  ppuunncctt
              ssppaaccee uuppppeerr wwoorrdd xxddiiggiitt
              A character class matches any character belonging to that class.
              The wwoorrdd character class matches letters, digits, and the  char-
              acter _.

              Within  [[ and ]], an _e_q_u_i_v_a_l_e_n_c_e _c_l_a_s_s can be specified using the
              syntax [[==_c==]], which matches all characters with the same  colla-
              tion  weight (as defined by the current locale) as the character
              _c.

              Within [[ and ]], the syntax [[.._s_y_m_b_o_l..]] matches the collating sym-
              bol _s_y_m_b_o_l.

       Several  extended  pattern  matching  operators are recognized.  In the
       following description, a _p_a_t_t_e_r_n_-_l_i_s_t is a list of one or more patterns
       separated  by  a ||.  Composite patterns may be formed using one or more
       of the following sub-patterns:

              ??((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches zero or one occurrence of the given patterns
              **((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches zero or more occurrences of the given patterns
              ++((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches one or more occurrences of the given patterns
              @@((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches one of the given patterns

       If the eexxttgglloobb shell option is enabled using the sshhoopptt builtin, follow-
       ing pattern matching operator is recognized as well:

              !!((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches anything except one of the given patterns

   QQuuoottee RReemmoovvaall
       After the preceding expansions, all unquoted occurrences of the charac-
       ters \\, '', and "" that did not result from one of the  above  expansions
       are removed.

RREEDDIIRREECCTTIIOONN
       Before  a  command  is executed, its input and output may be _r_e_d_i_r_e_c_t_e_d
       using a special notation interpreted by  the  shell.   Redirection  may
       also  be  used  to open and close files for the current shell execution
       environment.  The following redirection operators may precede or appear
       anywhere within a _s_i_m_p_l_e _c_o_m_m_a_n_d or may follow a _c_o_m_m_a_n_d.  Redirections
       are processed in the order they appear, from left to right.

       Each redirection that may be preceded by a file descriptor  number  may
       instead be preceded by a word of the form {_v_a_r_n_a_m_e}.  In this case, for
       each redirection operator except >&- and <&-, the shell will allocate a
       file  descriptor  greater  than 10 and assign it to _v_a_r_n_a_m_e.  If >&- or
       <&- is preceded by {_v_a_r_n_a_m_e}, the value of  _v_a_r_n_a_m_e  defines  the  file
       descriptor to close.

       In  the  following descriptions, if the file descriptor number is omit-
       ted, and the first character of the  redirection  operator  is  <<,  the
       redirection  refers  to the standard input (file descriptor 0).  If the
       first character of the  redirection  operator  is  >>,  the  redirection
       refers to the standard output (file descriptor 1).

       The  word  following the redirection operator in the following descrip-
       tions, unless otherwise noted, is subjected to brace  expansion,  tilde
       expansion, parameter expansion, command substitution, arithmetic expan-
       sion, quote removal, pathname expansion, and  word  splitting.   If  it
       expands to more than one word, bbaasshh reports an error.

       Note  that  the order of redirections is significant.  For example, the
       command

              ls >> dirlist 2>>&&1

       directs both standard output and standard error to  the  file  _d_i_r_l_i_s_t,
       while the command

              ls 2>>&&1 >> dirlist

       directs  only the standard output to file _d_i_r_l_i_s_t, because the standard
       error was duplicated from the standard output before the standard  out-
       put was redirected to _d_i_r_l_i_s_t.

       BBaasshh handles several filenames specially when they are used in redirec-
       tions, as described in the following table:

              //ddeevv//ffdd//_f_d
                     If _f_d is a valid integer, file descriptor  _f_d  is  dupli-
                     cated.
              //ddeevv//ssttddiinn
                     File descriptor 0 is duplicated.
              //ddeevv//ssttddoouutt
                     File descriptor 1 is duplicated.
              //ddeevv//ssttddeerrrr
                     File descriptor 2 is duplicated.
              //ddeevv//ttccpp//_h_o_s_t//_p_o_r_t
                     If _h_o_s_t is a valid hostname or Internet address, and _p_o_r_t
                     is an integer port number or service name, bbaasshh  attempts
                     to open a TCP connection to the corresponding socket.
              //ddeevv//uuddpp//_h_o_s_t//_p_o_r_t
                     If _h_o_s_t is a valid hostname or Internet address, and _p_o_r_t
                     is an integer port number or service name, bbaasshh  attempts
                     to open a UDP connection to the corresponding socket.

       A failure to open or create a file causes the redirection to fail.

       Redirections  using file descriptors greater than 9 should be used with
       care, as they may conflict with file descriptors the shell uses  inter-
       nally.

   RReeddiirreeccttiinngg IInnppuutt
       Redirection of input causes the file whose name results from the expan-
       sion of _w_o_r_d to be opened for reading on  file  descriptor  _n,  or  the
       standard input (file descriptor 0) if _n is not specified.

       The general format for redirecting input is:

              [_n]<<_w_o_r_d

   RReeddiirreeccttiinngg OOuuttppuutt
       Redirection  of  output  causes  the  file  whose name results from the
       expansion of _w_o_r_d to be opened for writing on file descriptor _n, or the
       standard output (file descriptor 1) if _n is not specified.  If the file
       does not exist it is created; if it does exist it is truncated to  zero
       size.

       The general format for redirecting output is:

              [_n]>>_w_o_r_d

       If  the  redirection operator is >>, and the nnoocclloobbbbeerr option to the sseett
       builtin has been enabled, the redirection will fail if the  file  whose
       name  results  from the expansion of _w_o_r_d exists and is a regular file.
       If the redirection operator is >>||, or the redirection operator is >> and
       the  nnoocclloobbbbeerr  option  to  the sseett builtin command is not enabled, the
       redirection is attempted even if the file named by _w_o_r_d exists.

   AAppppeennddiinngg RReeddiirreecctteedd OOuuttppuutt
       Redirection of output in  this  fashion  causes  the  file  whose  name
       results  from  the expansion of _w_o_r_d to be opened for appending on file
       descriptor _n, or the standard output (file descriptor 1) if  _n  is  not
       specified.  If the file does not exist it is created.

       The general format for appending output is:

              [_n]>>>>_w_o_r_d


   RReeddiirreeccttiinngg SSttaannddaarrdd OOuuttppuutt aanndd SSttaannddaarrdd EErrrroorr
       This  construct allows both the standard output (file descriptor 1) and
       the standard error output (file descriptor 2) to be redirected  to  the
       file whose name is the expansion of _w_o_r_d.

       There  are  two  formats  for  redirecting standard output and standard
       error:

              &&>>_w_o_r_d
       and
              >>&&_w_o_r_d

       Of the two forms, the first is preferred.  This is semantically equiva-
       lent to

              >>_w_o_r_d 2>>&&1


   AAppppeennddiinngg SSttaannddaarrdd OOuuttppuutt aanndd SSttaannddaarrdd EErrrroorr
       This  construct allows both the standard output (file descriptor 1) and
       the standard error output (file descriptor 2) to  be  appended  to  the
       file whose name is the expansion of _w_o_r_d.

       The format for appending standard output and standard error is:

              &&>>>>_w_o_r_d

       This is semantically equivalent to

              >>>>_w_o_r_d 2>>&&1

   HHeerree DDooccuummeennttss
       This  type  of  redirection  instructs the shell to read input from the
       current source until a line containing only _d_e_l_i_m_i_t_e_r (with no trailing
       blanks)  is seen.  All of the lines read up to that point are then used
       as the standard input for a command.

       The format of here-documents is:

              <<<<[--]_w_o_r_d
                      _h_e_r_e_-_d_o_c_u_m_e_n_t
              _d_e_l_i_m_i_t_e_r

       No parameter expansion, command substitution, arithmetic expansion,  or
       pathname expansion is performed on _w_o_r_d.  If any characters in _w_o_r_d are
       quoted, the _d_e_l_i_m_i_t_e_r is the result of quote removal on _w_o_r_d,  and  the
       lines  in the here-document are not expanded.  If _w_o_r_d is unquoted, all
       lines of the here-document are subjected to parameter  expansion,  com-
       mand  substitution,  and arithmetic expansion.  In the latter case, the
       character sequence \\<<nneewwlliinnee>> is ignored, and \\ must be used  to  quote
       the characters \\, $$, and ``.

       If the redirection operator is <<<<--, then all leading tab characters are
       stripped from input lines and  the  line  containing  _d_e_l_i_m_i_t_e_r.   This
       allows  here-documents within shell scripts to be indented in a natural
       fashion.

   HHeerree SSttrriinnggss
       A variant of here documents, the format is:

              <<<<<<_w_o_r_d

       The _w_o_r_d is expanded and supplied to the command on its standard input.

   DDuupplliiccaattiinngg FFiillee DDeessccrriippttoorrss
       The redirection operator

              [_n]<<&&_w_o_r_d

       is used to duplicate input file descriptors.  If _w_o_r_d expands to one or
       more digits, the file descriptor denoted by _n is made to be a  copy  of
       that  file  descriptor.   If  the  digits in _w_o_r_d do not specify a file
       descriptor open for input, a redirection error occurs.  If _w_o_r_d  evalu-
       ates  to  --,  file  descriptor _n is closed.  If _n is not specified, the
       standard input (file descriptor 0) is used.

       The operator

              [_n]>>&&_w_o_r_d

       is used similarly to duplicate output file descriptors.  If  _n  is  not
       specified,  the  standard  output  (file descriptor 1) is used.  If the
       digits in _w_o_r_d do not specify a file  descriptor  open  for  output,  a
       redirection error occurs.  As a special case, if _n is omitted, and _w_o_r_d
       does not expand to one or more digits, the standard output and standard
       error are redirected as described previously.

   MMoovviinngg FFiillee DDeessccrriippttoorrss
       The redirection operator

              [_n]<<&&_d_i_g_i_t--

       moves  the  file descriptor _d_i_g_i_t to file descriptor _n, or the standard
       input (file descriptor 0) if _n is not specified.  _d_i_g_i_t is closed after
       being duplicated to _n.

       Similarly, the redirection operator

              [_n]>>&&_d_i_g_i_t--

       moves  the  file descriptor _d_i_g_i_t to file descriptor _n, or the standard
       output (file descriptor 1) if _n is not specified.

   OOppeenniinngg FFiillee DDeessccrriippttoorrss ffoorr RReeaaddiinngg aanndd WWrriittiinngg
       The redirection operator

              [_n]<<>>_w_o_r_d

       causes the file whose name is the expansion of _w_o_r_d to  be  opened  for
       both  reading and writing on file descriptor _n, or on file descriptor 0
       if _n is not specified.  If the file does not exist, it is created.

AALLIIAASSEESS
       _A_l_i_a_s_e_s allow a string to be substituted for a word when it is used  as
       the  first  word  of  a  simple command.  The shell maintains a list of
       aliases that may be set and unset with the aalliiaass  and  uunnaalliiaass  builtin
       commands  (see  SSHHEELLLL  BBUUIILLTTIINN CCOOMMMMAANNDDSS below).  The first word of each
       simple command, if unquoted, is checked to see if it has an alias.   If
       so,  that word is replaced by the text of the alias.  The characters //,
       $$, ``, and == and any of the shell _m_e_t_a_c_h_a_r_a_c_t_e_r_s or  quoting  characters
       listed above may not appear in an alias name.  The replacement text may
       contain any valid shell input,  including  shell  metacharacters.   The
       first  word  of  the replacement text is tested for aliases, but a word
       that is identical to an alias being expanded is not expanded  a  second
       time.   This  means  that  one may alias llss to llss --FF, for instance, and
       bbaasshh does not try to recursively expand the replacement text.   If  the
       last  character  of  the  alias value is a _b_l_a_n_k, then the next command
       word following the alias is also checked for alias expansion.

       Aliases are created and listed with the aalliiaass command, and removed with
       the uunnaalliiaass command.

       There  is no mechanism for using arguments in the replacement text.  If
       arguments are needed, a shell function should be  used  (see  FFUUNNCCTTIIOONNSS
       below).

       Aliases  are not expanded when the shell is not interactive, unless the
       eexxppaanndd__aalliiaasseess shell option is set using sshhoopptt (see the description  of
       sshhoopptt under SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).

       The  rules  concerning  the  definition and use of aliases are somewhat
       confusing.  BBaasshh always reads at  least  one  complete  line  of  input
       before  executing  any  of  the  commands  on  that  line.  Aliases are
       expanded when a command is read, not when it is  executed.   Therefore,
       an  alias definition appearing on the same line as another command does
       not take effect until the next line of input  is  read.   The  commands
       following the alias definition on that line are not affected by the new
       alias.  This behavior is also an issue  when  functions  are  executed.
       Aliases  are  expanded when a function definition is read, not when the
       function is executed, because a function definition is  itself  a  com-
       pound command.  As a consequence, aliases defined in a function are not
       available until after that function is executed.  To  be  safe,  always
       put  alias definitions on a separate line, and do not use aalliiaass in com-
       pound commands.

       For almost every purpose, aliases are superseded by shell functions.

FFUUNNCCTTIIOONNSS
       A shell function, defined  as  described  above  under  SSHHEELLLL  GGRRAAMMMMAARR,
       stores  a  series  of commands for later execution.  When the name of a
       shell function is used as a simple command name, the list  of  commands
       associated with that function name is executed.  Functions are executed
       in the context of the current shell;  no  new  process  is  created  to
       interpret  them  (contrast  this with the execution of a shell script).
       When a function is executed, the arguments to the function  become  the
       positional parameters during its execution.  The special parameter ## is
       updated to reflect the change.  Special parameter 0 is unchanged.   The
       first  element of the FFUUNNCCNNAAMMEE variable is set to the name of the func-
       tion while the function is executing.

       All other aspects of the  shell  execution  environment  are  identical
       between a function and its caller with these exceptions:  the DDEEBBUUGG and
       RREETTUURRNN traps (see the description  of  the  ttrraapp  builtin  under  SSHHEELLLL
       BBUUIILLTTIINN  CCOOMMMMAANNDDSS below) are not inherited unless the function has been
       given the ttrraaccee attribute (see the description of the  ddeeccllaarree  builtin
       below)  or  the --oo ffuunnccttrraaccee shell option has been enabled with the sseett
       builtin (in which case all  functions  inherit  the  DDEEBBUUGG  and  RREETTUURRNN
       traps),  and the EERRRR trap is not inherited unless the --oo eerrrrttrraaccee shell
       option has been enabled.

       Variables local to the function may be declared with the llooccaall  builtin
       command.  Ordinarily, variables and their values are shared between the
       function and its caller.

       If the builtin command rreettuurrnn is executed in a function,  the  function
       completes  and  execution resumes with the next command after the func-
       tion call.  Any command associated with the  RREETTUURRNN  trap  is  executed
       before execution resumes.  When a function completes, the values of the
       positional parameters and the special parameter ## are restored  to  the
       values they had prior to the function’s execution.

       Function  names and definitions may be listed with the --ff option to the
       ddeeccllaarree or ttyyppeesseett builtin commands.  The --FF option to ddeeccllaarree or ttyyppee--
       sseett  will  list the function names only (and optionally the source file
       and line number, if the eexxttddeebbuugg shell option is  enabled).   Functions
       may  be exported so that subshells automatically have them defined with
       the --ff option to the eexxppoorrtt builtin.   A  function  definition  may  be
       deleted  using  the  --ff  option  to the uunnsseett builtin.  Note that shell
       functions and variables with the same name may result in multiple iden-
       tically-named  entries  in  the environment passed to the shell’s chil-
       dren.  Care should be taken in cases where this may cause a problem.

       Functions may be recursive.  No limit  is  imposed  on  the  number  of
       recursive calls.

AARRIITTHHMMEETTIICC EEVVAALLUUAATTIIOONN
       The  shell allows arithmetic expressions to be evaluated, under certain
       circumstances (see the lleett and ddeeccllaarree builtin commands and  AArriitthhmmeettiicc
       EExxppaannssiioonn).   Evaluation  is done in fixed-width integers with no check
       for overflow, though division by 0 is trapped and flagged as an  error.
       The  operators  and their precedence, associativity, and values are the
       same as in the C language.  The following list of operators is  grouped
       into  levels  of  equal-precedence operators.  The levels are listed in
       order of decreasing precedence.

       _i_d++++ _i_d----
              variable post-increment and post-decrement
       ++++_i_d ----_i_d
              variable pre-increment and pre-decrement
       -- ++    unary minus and plus
       !! ~~    logical and bitwise negation
       ****     exponentiation
       ** // %%  multiplication, division, remainder
       ++ --    addition, subtraction
       <<<< >>>>  left and right bitwise shifts
       <<== >>== << >>
              comparison
       ==== !!==  equality and inequality
       &&      bitwise AND
       ^^      bitwise exclusive OR
       ||      bitwise OR
       &&&&     logical AND
       ||||     logical OR
       _e_x_p_r??_e_x_p_r::_e_x_p_r
              conditional operator
       == **== //== %%== ++== --== <<<<== >>>>== &&== ^^== ||==
              assignment
       _e_x_p_r_1 ,, _e_x_p_r_2
              comma

       Shell variables are allowed as operands; parameter  expansion  is  per-
       formed before the expression is evaluated.  Within an expression, shell
       variables may also be referenced by name without  using  the  parameter
       expansion  syntax.  A shell variable that is null or unset evaluates to
       0 when referenced by name without using the parameter expansion syntax.
       The  value  of a variable is evaluated as an arithmetic expression when
       it is referenced, or when a variable which has been given  the  _i_n_t_e_g_e_r
       attribute using ddeeccllaarree --ii is assigned a value.  A null value evaluates
       to 0.  A shell variable need not have its integer attribute  turned  on
       to be used in an expression.

       Constants with a leading 0 are interpreted as octal numbers.  A leading
       0x or  0X  denotes  hexadecimal.   Otherwise,  numbers  take  the  form
       [_b_a_s_e_#]n,  where _b_a_s_e is a decimal number between 2 and 64 representing
       the arithmetic base, and _n is a number in that base.  If _b_a_s_e_# is omit-
       ted,  then  base 10 is used.  The digits greater than 9 are represented
       by the lowercase letters, the uppercase letters,  @,  and  _,  in  that
       order.   If  _b_a_s_e  is less than or equal to 36, lowercase and uppercase
       letters may be used interchangeably to represent numbers between 10 and
       35.

       Operators  are  evaluated  in  order of precedence.  Sub-expressions in
       parentheses are evaluated first and may override the  precedence  rules
       above.

CCOONNDDIITTIIOONNAALL EEXXPPRREESSSSIIOONNSS
       Conditional  expressions  are  used  by the [[[[ compound command and the
       tteesstt and [[ builtin commands to test file attributes and perform  string
       and  arithmetic comparisons.  Expressions are formed from the following
       unary or binary primaries.  If any _f_i_l_e argument to  one  of  the  pri-
       maries is of the form _/_d_e_v_/_f_d_/_n, then file descriptor _n is checked.  If
       the _f_i_l_e argument to  one  of  the  primaries  is  one  of  _/_d_e_v_/_s_t_d_i_n,
       _/_d_e_v_/_s_t_d_o_u_t,  or _/_d_e_v_/_s_t_d_e_r_r, file descriptor 0, 1, or 2, respectively,
       is checked.

       Unless otherwise specified, primaries that operate on files follow sym-
       bolic links and operate on the target of the link, rather than the link
       itself.

       When used with [[[[, The << and >> operators sort  lexicographically  using
       the current locale.

       --aa _f_i_l_e
              True if _f_i_l_e exists.
       --bb _f_i_l_e
              True if _f_i_l_e exists and is a block special file.
       --cc _f_i_l_e
              True if _f_i_l_e exists and is a character special file.
       --dd _f_i_l_e
              True if _f_i_l_e exists and is a directory.
       --ee _f_i_l_e
              True if _f_i_l_e exists.
       --ff _f_i_l_e
              True if _f_i_l_e exists and is a regular file.
       --gg _f_i_l_e
              True if _f_i_l_e exists and is set-group-id.
       --hh _f_i_l_e
              True if _f_i_l_e exists and is a symbolic link.
       --kk _f_i_l_e
              True if _f_i_l_e exists and its ‘‘sticky’’ bit is set.
       --pp _f_i_l_e
              True if _f_i_l_e exists and is a named pipe (FIFO).
       --rr _f_i_l_e
              True if _f_i_l_e exists and is readable.
       --ss _f_i_l_e
              True if _f_i_l_e exists and has a size greater than zero.
       --tt _f_d  True if file descriptor _f_d is open and refers to a terminal.
       --uu _f_i_l_e
              True if _f_i_l_e exists and its set-user-id bit is set.
       --ww _f_i_l_e
              True if _f_i_l_e exists and is writable.
       --xx _f_i_l_e
              True if _f_i_l_e exists and is executable.
       --OO _f_i_l_e
              True if _f_i_l_e exists and is owned by the effective user id.
       --GG _f_i_l_e
              True if _f_i_l_e exists and is owned by the effective group id.
       --LL _f_i_l_e
              True if _f_i_l_e exists and is a symbolic link.
       --SS _f_i_l_e
              True if _f_i_l_e exists and is a socket.
       --NN _f_i_l_e
              True  if  _f_i_l_e  exists  and  has been modified since it was last
              read.
       _f_i_l_e_1 -nntt _f_i_l_e_2
              True if _f_i_l_e_1 is newer (according  to  modification  date)  than
              _f_i_l_e_2, or if _f_i_l_e_1 exists and _f_i_l_e_2 does not.
       _f_i_l_e_1 -oott _f_i_l_e_2
              True  if _f_i_l_e_1 is older than _f_i_l_e_2, or if _f_i_l_e_2 exists and _f_i_l_e_1
              does not.
       _f_i_l_e_1 --eeff _f_i_l_e_2
              True if _f_i_l_e_1 and _f_i_l_e_2 refer to the same device and inode  num-
              bers.
       --oo _o_p_t_n_a_m_e
              True  if  shell  option  _o_p_t_n_a_m_e  is  enabled.   See the list of
              options under the description  of  the  --oo  option  to  the  sseett
              builtin below.
       --zz _s_t_r_i_n_g
              True if the length of _s_t_r_i_n_g is zero.
       _s_t_r_i_n_g
       --nn _s_t_r_i_n_g
              True if the length of _s_t_r_i_n_g is non-zero.

       _s_t_r_i_n_g_1 ==== _s_t_r_i_n_g_2
       _s_t_r_i_n_g_1 == _s_t_r_i_n_g_2
              True  if  the strings are equal.  == should be used with the tteesstt
              command for POSIX conformance.

       _s_t_r_i_n_g_1 !!== _s_t_r_i_n_g_2
              True if the strings are not equal.

       _s_t_r_i_n_g_1 << _s_t_r_i_n_g_2
              True if _s_t_r_i_n_g_1 sorts before _s_t_r_i_n_g_2 lexicographically.

       _s_t_r_i_n_g_1 >> _s_t_r_i_n_g_2
              True if _s_t_r_i_n_g_1 sorts after _s_t_r_i_n_g_2 lexicographically.

       _a_r_g_1 OOPP _a_r_g_2
              OOPP is one of --eeqq, --nnee, --lltt, --llee, --ggtt, or --ggee.  These  arithmetic
              binary  operators return true if _a_r_g_1 is equal to, not equal to,
              less than, less than or equal to, greater than, or greater  than
              or  equal  to _a_r_g_2, respectively.  _A_r_g_1 and _a_r_g_2 may be positive
              or negative integers.

SSIIMMPPLLEE CCOOMMMMAANNDD EEXXPPAANNSSIIOONN
       When a simple command is executed, the  shell  performs  the  following
       expansions, assignments, and redirections, from left to right.

       1.     The  words  that  the  parser has marked as variable assignments
              (those preceding the command name) and  redirections  are  saved
              for later processing.

       2.     The  words that are not variable assignments or redirections are
              expanded.  If any words remain after expansion, the  first  word
              is  taken  to be the name of the command and the remaining words
              are the arguments.

       3.     Redirections are performed as described above under RREEDDIIRREECCTTIIOONN.

       4.     The text after the == in each variable assignment undergoes tilde
              expansion, parameter expansion, command substitution, arithmetic
              expansion,  and quote removal before being assigned to the vari-
              able.

       If no command name results, the variable assignments affect the current
       shell  environment.  Otherwise, the variables are added to the environ-
       ment of the executed command and do not affect the current shell  envi-
       ronment.   If  any  of  the assignments attempts to assign a value to a
       readonly variable, an error occurs, and the command exits with  a  non-
       zero status.

       If  no  command  name  results,  redirections are performed, but do not
       affect the current shell environment.  A redirection error  causes  the
       command to exit with a non-zero status.

       If  there is a command name left after expansion, execution proceeds as
       described below.  Otherwise, the command exits.  If one of  the  expan-
       sions  contained a command substitution, the exit status of the command
       is the exit status of the  last  command  substitution  performed.   If
       there were no command substitutions, the command exits with a status of
       zero.

CCOOMMMMAANNDD EEXXEECCUUTTIIOONN
       After a command has been split into words, if it results  in  a  simple
       command  and  an  optional list of arguments, the following actions are
       taken.

       If the command name contains no slashes, the shell attempts  to  locate
       it.   If  there  exists a shell function by that name, that function is
       invoked as described above in FFUUNNCCTTIIOONNSS.  If the name does not match  a
       function,  the shell searches for it in the list of shell builtins.  If
       a match is found, that builtin is invoked.

       If the name is neither a shell function nor a builtin, and contains  no
       slashes,  bbaasshh  searches  each element of the PPAATTHH for a directory con-
       taining an executable file by that name.  BBaasshh uses  a  hash  table  to
       remember  the  full pathnames of executable files (see hhaasshh under SSHHEELLLL
       BBUUIILLTTIINN CCOOMMMMAANNDDSS below).  A full search of the directories in  PPAATTHH  is
       performed  only  if the command is not found in the hash table.  If the
       search is unsuccessful, the shell searches for a defined shell function
       named ccoommmmaanndd__nnoott__ffoouunndd__hhaannddllee.  If that function exists, it is invoked
       with the original command and the original command’s arguments  as  its
       arguments,  and  the  function’s exit status becomes the exit status of
       the shell.  If that function is not defined, the shell prints an  error
       message and returns an exit status of 127.

       If  the  search  is  successful, or if the command name contains one or
       more slashes, the shell executes the named program in a separate execu-
       tion environment.  Argument 0 is set to the name given, and the remain-
       ing arguments to the command are set to the arguments given, if any.

       If this execution fails because the file is not in  executable  format,
       and  the file is not a directory, it is assumed to be a _s_h_e_l_l _s_c_r_i_p_t, a
       file containing shell commands.  A subshell is spawned to  execute  it.
       This  subshell  reinitializes itself, so that the effect is as if a new
       shell had been invoked to handle the script, with  the  exception  that
       the  locations  of  commands  remembered  by the parent (see hhaasshh below
       under SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS) are retained by the child.

       If the program is a file beginning with ##!!, the remainder of the  first
       line  specifies an interpreter for the program.  The shell executes the
       specified interpreter on operating systems that do not handle this exe-
       cutable format themselves.  The arguments to the interpreter consist of
       a single optional argument following the interpreter name on the  first
       line  of  the program, followed by the name of the program, followed by
       the command arguments, if any.

CCOOMMMMAANNDD EEXXEECCUUTTIIOONN EENNVVIIRROONNMMEENNTT
       The shell has an _e_x_e_c_u_t_i_o_n _e_n_v_i_r_o_n_m_e_n_t, which consists of  the  follow-
       ing:


       ·      open  files inherited by the shell at invocation, as modified by
              redirections supplied to the eexxeecc builtin

       ·      the current working directory as set by ccdd, ppuusshhdd, or  ppooppdd,  or
              inherited by the shell at invocation

       ·      the  file  creation  mode mask as set by uummaasskk or inherited from
              the shell’s parent

       ·      current traps set by ttrraapp

       ·      shell parameters that are set by variable assignment or with sseett
              or inherited from the shell’s parent in the environment

       ·      shell  functions  defined during execution or inherited from the
              shell’s parent in the environment

       ·      options enabled at invocation (either by default  or  with  com-
              mand-line arguments) or by sseett

       ·      options enabled by sshhoopptt

       ·      shell aliases defined with aalliiaass

       ·      various  process  IDs,  including  those of background jobs, the
              value of $$$$, and the value of PPPPIIDD

       When a simple command other than a builtin or shell function is  to  be
       executed,  it  is invoked in a separate execution environment that con-
       sists of the following.  Unless otherwise noted, the values are  inher-
       ited from the shell.


       ·      the  shell’s  open  files,  plus any modifications and additions
              specified by redirections to the command

       ·      the current working directory

       ·      the file creation mode mask

       ·      shell variables and functions  marked  for  export,  along  with
              variables exported for the command, passed in the environment

       ·      traps caught by the shell are reset to the values inherited from
              the shell’s parent, and traps ignored by the shell are ignored

       A command invoked  in  this  separate  environment  cannot  affect  the
       shell’s execution environment.

       Command  substitution,  commands  grouped  with  parentheses, and asyn-
       chronous commands are invoked in  a  subshell  environment  that  is  a
       duplicate  of  the  shell  environment, except that traps caught by the
       shell are reset to the values that the shell inherited from its  parent
       at invocation.  Builtin commands that are invoked as part of a pipeline
       are also executed in a subshell environment.  Changes made to the  sub-
       shell environment cannot affect the shell’s execution environment.

       Subshells spawned to execute command substitutions inherit the value of
       the --ee option from the parent shell.  When  not  in  posix  mode,  Bash
       clears the --ee option in such subshells.

       If  a  command  is  followed  by a && and job control is not active, the
       default standard input for the command is  the  empty  file  _/_d_e_v_/_n_u_l_l.
       Otherwise,  the  invoked  command  inherits the file descriptors of the
       calling shell as modified by redirections.

EENNVVIIRROONNMMEENNTT
       When a program is invoked it is given an array of  strings  called  the
       _e_n_v_i_r_o_n_m_e_n_t.   This  is  a  list  of  _n_a_m_e-_v_a_l_u_e  pairs,  of  the  form
       _n_a_m_e=_v_a_l_u_e.

       The shell provides several ways  to  manipulate  the  environment.   On
       invocation, the shell scans its own environment and creates a parameter
       for each name found, automatically marking it for _e_x_p_o_r_t to child  pro-
       cesses.   Executed  commands  inherit  the environment.  The eexxppoorrtt and
       ddeeccllaarree --xx commands allow parameters and functions to be added  to  and
       deleted from the environment.  If the value of a parameter in the envi-
       ronment is modified, the new value becomes  part  of  the  environment,
       replacing  the  old.  The environment inherited by any executed command
       consists of the shell’s initial environment, whose values may be  modi-
       fied  in  the  shell, less any pairs removed by the uunnsseett command, plus
       any additions via the eexxppoorrtt and ddeeccllaarree --xx commands.

       The environment for any _s_i_m_p_l_e _c_o_m_m_a_n_d or  function  may  be  augmented
       temporarily  by  prefixing  it with parameter assignments, as described
       above in PPAARRAAMMEETTEERRSS.  These assignment statements affect only the envi-
       ronment seen by that command.

       If  the  --kk option is set (see the sseett builtin command below), then _a_l_l
       parameter assignments are placed in the environment for a command,  not
       just those that precede the command name.

       When  bbaasshh  invokes  an  external command, the variable __ is set to the
       full file name of the command and passed to that command in  its  envi-
       ronment.

EEXXIITT SSTTAATTUUSS
       The  exit  status  of  an executed command is the value returned by the
       _w_a_i_t_p_i_d system call or equivalent function.  Exit statuses fall between
       0  and  255, though, as explained below, the shell may use values above
       125 specially.  Exit statuses from shell builtins and compound commands
       are  also limited to this range. Under certain circumstances, the shell
       will use special values to indicate specific failure modes.

       For the shell’s purposes, a command which exits with a zero exit status
       has  succeeded.   An exit status of zero indicates success.  A non-zero
       exit status indicates failure.  When a command terminates  on  a  fatal
       signal _N, bbaasshh uses the value of 128+_N as the exit status.

       If  a  command  is  not  found, the child process created to execute it
       returns a status of 127.  If a command is found but is not  executable,
       the return status is 126.

       If a command fails because of an error during expansion or redirection,
       the exit status is greater than zero.

       Shell builtin commands return a status of 0 (_t_r_u_e) if  successful,  and
       non-zero  (_f_a_l_s_e)  if an error occurs while they execute.  All builtins
       return an exit status of 2 to indicate incorrect usage.

       BBaasshh itself returns the exit  status  of  the  last  command  executed,
       unless  a  syntax  error occurs, in which case it exits with a non-zero
       value.  See also the eexxiitt builtin command below.

SSIIGGNNAALLSS
       When bbaasshh is interactive, in the  absence  of  any  traps,  it  ignores
       SSIIGGTTEERRMM (so that kkiillll 00 does not kill an interactive shell), and SSIIGGIINNTT
       is caught and handled (so that the wwaaiitt builtin is interruptible).   In
       all  cases,  bbaasshh  ignores  SSIIGGQQUUIITT.  If job control is in effect, bbaasshh
       ignores SSIIGGTTTTIINN, SSIIGGTTTTOOUU, and SSIIGGTTSSTTPP.

       Non-builtin commands run by bbaasshh have signal handlers set to the values
       inherited  by  the  shell  from its parent.  When job control is not in
       effect, asynchronous commands ignore SSIIGGIINNTT and SSIIGGQQUUIITT in addition  to
       these  inherited handlers.  Commands run as a result of command substi-
       tution ignore the keyboard-generated job control signals SSIIGGTTTTIINN, SSIIGGTT--
       TTOOUU, and SSIIGGTTSSTTPP.

       The  shell  exits by default upon receipt of a SSIIGGHHUUPP.  Before exiting,
       an interactive shell  resends  the  SSIIGGHHUUPP  to  all  jobs,  running  or
       stopped.  Stopped jobs are sent SSIIGGCCOONNTT to ensure that they receive the
       SSIIGGHHUUPP.  To prevent the shell from sending the signal to  a  particular
       job,  it  should be removed from the jobs table with the ddiissoowwnn builtin
       (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below) or  marked  to  not  receive  SSIIGGHHUUPP
       using ddiissoowwnn --hh.

       If  the  hhuuppoonneexxiitt  shell  option has been set with sshhoopptt, bbaasshh sends a
       SSIIGGHHUUPP to all jobs when an interactive login shell exits.

       If bbaasshh is waiting for a command to complete and receives a signal  for
       which a trap has been set, the trap will not be executed until the com-
       mand completes.  When bbaasshh is waiting for an asynchronous  command  via
       the  wwaaiitt  builtin, the reception of a signal for which a trap has been
       set will cause the wwaaiitt builtin to return immediately with an exit sta-
       tus greater than 128, immediately after which the trap is executed.

JJOOBB CCOONNTTRROOLL
       _J_o_b  _c_o_n_t_r_o_l  refers  to  the ability to selectively stop (_s_u_s_p_e_n_d) the
       execution of processes and continue (_r_e_s_u_m_e) their execution at a later
       point.   A  user  typically  employs  this  facility via an interactive
       interface supplied jointly by the operating  system  kernel’s  terminal
       driver and bbaasshh.

       The  shell  associates  a  _j_o_b with each pipeline.  It keeps a table of
       currently executing jobs, which may be listed with  the  jjoobbss  command.
       When  bbaasshh starts a job asynchronously (in the _b_a_c_k_g_r_o_u_n_d), it prints a
       line that looks like:

              [1] 25647

       indicating that this job is job number 1 and that the process ID of the
       last process in the pipeline associated with this job is 25647.  All of
       the processes in a single pipeline are members of the same  job.   BBaasshh
       uses the _j_o_b abstraction as the basis for job control.

       To  facilitate the implementation of the user interface to job control,
       the operating system maintains the notion of a _c_u_r_r_e_n_t _t_e_r_m_i_n_a_l _p_r_o_c_e_s_s
       _g_r_o_u_p _I_D.  Members of this process group (processes whose process group
       ID is equal to the current terminal process group ID) receive keyboard-
       generated  signals  such  as SSIIGGIINNTT.  These processes are said to be in
       the _f_o_r_e_g_r_o_u_n_d.  _B_a_c_k_g_r_o_u_n_d processes are those whose process group  ID
       differs from the terminal’s; such processes are immune to keyboard-gen-
       erated signals.  Only foreground processes are allowed to read from or,
       if  the  user  so  specifies  with  stty tostop, write to the terminal.
       Background processes which attempt to read from  (write  to  when  stty
       tostop  is  in effect) the terminal are sent a SSIIGGTTTTIINN ((SSIIGGTTTTOOUU)) signal
       by the kernel’s terminal driver, which,  unless  caught,  suspends  the
       process.

       If  the operating system on which bbaasshh is running supports job control,
       bbaasshh contains facilities to use it.  Typing the _s_u_s_p_e_n_d character (typ-
       ically ^^ZZ, Control-Z) while a process is running causes that process to
       be stopped and returns control to bbaasshh.   Typing  the  _d_e_l_a_y_e_d  _s_u_s_p_e_n_d
       character  (typically  ^^YY,  Control-Y) causes the process to be stopped
       when it attempts to read input from the terminal,  and  control  to  be
       returned  to bbaasshh.  The user may then manipulate the state of this job,
       using the bbgg command to continue it in the background, the  ffgg  command
       to continue it in the foreground, or the kkiillll command to kill it.  A ^^ZZ
       takes effect immediately, and has the additional side effect of causing
       pending output and typeahead to be discarded.

       There are a number of ways to refer to a job in the shell.  The charac-
       ter %% introduces a job specification (_j_o_b_s_p_e_c).  Job number  _n  may  be
       referred to as %%nn.  A job may also be referred to using a prefix of the
       name used to start it, or using a substring that appears in its command
       line.   For  example,  %%ccee  refers  to  a  stopped ccee job.  If a prefix
       matches more than one job, bbaasshh reports an error.  Using %%??ccee,  on  the
       other  hand,  refers to any job containing the string ccee in its command
       line.  If the substring matches more than  one  job,  bbaasshh  reports  an
       error.   The  symbols %%%% and %%++ refer to the shell’s notion of the _c_u_r_-
       _r_e_n_t _j_o_b, which is the last job stopped while it was in the  foreground
       or started in the background.  The _p_r_e_v_i_o_u_s _j_o_b may be referenced using
       %%--.  If there is only a single job, %%++ and %%-- can both be used to refer
       to  that  job.   In  output pertaining to jobs (e.g., the output of the
       jjoobbss command), the current job is always flagged with a ++, and the pre-
       vious  job  with  a --.  A single % (with no accompanying job specifica-
       tion) also refers to the current job.

       Simply naming a job can be used to bring it into the foreground: %%11  is
       a  synonym  for  ‘‘‘‘ffgg %%11’’’’, bringing job 1 from the background into the
       foreground.  Similarly, ‘‘‘‘%%11 &&’’’’  resumes  job  1  in  the  background,
       equivalent to ‘‘‘‘bbgg %%11’’’’.

       The  shell  learns immediately whenever a job changes state.  Normally,
       bbaasshh waits until it is about to print a prompt before reporting changes
       in  a  job’s status so as to not interrupt any other output.  If the --bb
       option to the sseett builtin command is enabled, bbaasshh reports such changes
       immediately.   Any  trap  on  SSIIGGCCHHLLDD  is  executed for each child that
       exits.

       If an attempt to exit bbaasshh is made while jobs are stopped (or,  if  the
       cchheecckkjjoobbss  shell  option has been enabled using the sshhoopptt builtin, run-
       ning), the shell prints a warning message, and, if the cchheecckkjjoobbss option
       is  enabled,  lists  the jobs and their statuses.  The jjoobbss command may
       then be used to inspect their status.  If a second attempt to  exit  is
       made  without  an intervening command, the shell does not print another
       warning, and any stopped jobs are terminated.

PPRROOMMPPTTIINNGG
       When executing interactively, bbaasshh displays the primary prompt PPSS11 when
       it  is  ready  to  read a command, and the secondary prompt PPSS22 when it
       needs more input to complete  a  command.   BBaasshh  allows  these  prompt
       strings  to  be  customized  by inserting a number of backslash-escaped
       special characters that are decoded as follows:
              \\aa     an ASCII bell character (07)
              \\dd     the date in "Weekday Month Date" format (e.g.,  "Tue  May
                     26")
              \\DD{{_f_o_r_m_a_t}}
                     the  _f_o_r_m_a_t  is  passed  to _s_t_r_f_t_i_m_e(3) and the result is
                     inserted into the prompt string; an empty _f_o_r_m_a_t  results
                     in a locale-specific time representation.  The braces are
                     required
              \\ee     an ASCII escape character (033)
              \\hh     the hostname up to the first ‘.’
              \\HH     the hostname
              \\jj     the number of jobs currently managed by the shell
              \\ll     the basename of the shell’s terminal device name
              \\nn     newline
              \\rr     carriage return
              \\ss     the name of the shell, the basename of  $$00  (the  portion
                     following the final slash)
              \\tt     the current time in 24-hour HH:MM:SS format
              \\TT     the current time in 12-hour HH:MM:SS format
              \\@@     the current time in 12-hour am/pm format
              \\AA     the current time in 24-hour HH:MM format
              \\uu     the username of the current user
              \\vv     the version of bbaasshh (e.g., 2.00)
              \\VV     the release of bbaasshh, version + patch level (e.g., 2.00.0)
              \\ww     the current working  directory,  with  $$HHOOMMEE  abbreviated
                     with  a tilde (uses the value of the PPRROOMMPPTT__DDIIRRTTRRIIMM vari-
                     able)
              \\WW     the basename of the current working directory, with $$HHOOMMEE
                     abbreviated with a tilde
              \\!!     the history number of this command
              \\##     the command number of this command
              \\$$     if the effective UID is 0, a ##, otherwise a $$
              \\_n_n_n   the character corresponding to the octal number _n_n_n
              \\\\     a backslash
              \\[[     begin  a sequence of non-printing characters, which could
                     be used to embed a terminal  control  sequence  into  the
                     prompt
              \\]]     end a sequence of non-printing characters

       The  command  number  and the history number are usually different: the
       history number of a command is its position in the history list,  which
       may  include  commands  restored  from  the  history  file (see HHIISSTTOORRYY
       below), while the command number is the position  in  the  sequence  of
       commands  executed  during the current shell session.  After the string
       is decoded, it is expanded via parameter expansion,  command  substitu-
       tion,  arithmetic expansion, and quote removal, subject to the value of
       the pprroommppttvvaarrss shell option (see the description of the  sshhoopptt  command
       under SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).

RREEAADDLLIINNEE
       This  is  the library that handles reading input when using an interac-
       tive shell, unless the ----nnooeeddiittiinngg option is given at shell invocation.
       Line editing is also used when using the --ee option to the rreeaadd builtin.
       By default, the line editing commands are similar to those of emacs.  A
       vi-style line editing interface is also available.  Line editing can be
       enabled at any time using the --oo eemmaaccss or --oo  vvii  options  to  the  sseett
       builtin  (see  SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).  To turn off line editing
       after the shell is running, use the ++oo eemmaaccss or ++oo vvii  options  to  the
       sseett builtin.

   RReeaaddlliinnee NNoottaattiioonn
       In this section, the emacs-style notation is used to denote keystrokes.
       Control keys are denoted by C-_k_e_y, e.g., C-n  means  Control-N.   Simi-
       larly,  _m_e_t_a  keys are denoted by M-_k_e_y, so M-x means Meta-X.  (On key-
       boards without a _m_e_t_a key, M-_x means ESC _x, i.e., press the Escape  key
       then the _x key.  This makes ESC the _m_e_t_a _p_r_e_f_i_x.  The combination M-C-_x
       means ESC-Control-_x, or press the Escape key then hold the Control  key
       while pressing the _x key.)

       Readline commands may be given numeric _a_r_g_u_m_e_n_t_s, which normally act as
       a repeat count.  Sometimes, however, it is the  sign  of  the  argument
       that  is  significant.   Passing  a negative argument to a command that
       acts in the forward direction (e.g., kkiillll--lliinnee) causes that command  to
       act  in  a  backward direction.  Commands whose behavior with arguments
       deviates from this are noted below.

       When a command is described as _k_i_l_l_i_n_g text, the text deleted is  saved
       for possible future retrieval (_y_a_n_k_i_n_g).  The killed text is saved in a
       _k_i_l_l _r_i_n_g.  Consecutive kills cause the text to be accumulated into one
       unit, which can be yanked all at once.  Commands which do not kill text
       separate the chunks of text on the kill ring.

   RReeaaddlliinnee IInniittiiaalliizzaattiioonn
       Readline is customized by putting commands in  an  initialization  file
       (the  _i_n_p_u_t_r_c  file).  The name of this file is taken from the value of
       the IINNPPUUTTRRCC variable.  If  that  variable  is  unset,  the  default  is
       _~_/_._i_n_p_u_t_r_c.   When a program which uses the readline library starts up,
       the initialization file is read, and the key bindings and variables are
       set.   There  are  only  a few basic constructs allowed in the readline
       initialization file.  Blank lines are ignored.  Lines beginning with  a
       ##  are  comments.   Lines  beginning with a $$ indicate conditional con-
       structs.  Other lines denote key bindings and variable settings.

       The default key-bindings may be changed with an  _i_n_p_u_t_r_c  file.   Other
       programs that use this library may add their own commands and bindings.

       For example, placing

              M-Control-u: universal-argument
       or
              C-Meta-u: universal-argument
       into the _i_n_p_u_t_r_c would make M-C-u execute the readline command  _u_n_i_v_e_r_-
       _s_a_l_-_a_r_g_u_m_e_n_t.

       The  following  symbolic  character  names are recognized: _R_U_B_O_U_T, _D_E_L,
       _E_S_C, _L_F_D, _N_E_W_L_I_N_E, _R_E_T, _R_E_T_U_R_N, _S_P_C, _S_P_A_C_E, and _T_A_B.

       In addition to command names, readline allows keys to  be  bound  to  a
       string that is inserted when the key is pressed (a _m_a_c_r_o).

   RReeaaddlliinnee KKeeyy BBiinnddiinnggss
       The  syntax for controlling key bindings in the _i_n_p_u_t_r_c file is simple.
       All that is required is the name of the command or the text of a  macro
       and  a key sequence to which it should be bound. The name may be speci-
       fied in one of two ways: as a symbolic key name, possibly with _M_e_t_a_- or
       _C_o_n_t_r_o_l_- prefixes, or as a key sequence.

       When using the form kkeeyynnaammee:_f_u_n_c_t_i_o_n_-_n_a_m_e or _m_a_c_r_o, _k_e_y_n_a_m_e is the name
       of a key spelled out in English.  For example:

              Control-u: universal-argument
              Meta-Rubout: backward-kill-word
              Control-o: "> output"

       In the above example, _C_-_u is bound to the function  uunniivveerrssaall--aarrgguummeenntt,
       _M_-_D_E_L  is bound to the function bbaacckkwwaarrdd--kkiillll--wwoorrdd, and _C_-_o is bound to
       run the macro expressed on the right hand side (that is, to insert  the
       text ‘‘> output’’ into the line).

       In  the  second  form,  ""kkeeyysseeqq"":_f_u_n_c_t_i_o_n_-_n_a_m_e or _m_a_c_r_o, kkeeyysseeqq differs
       from kkeeyynnaammee above in that strings denoting an entire key sequence  may
       be  specified  by  placing the sequence within double quotes.  Some GNU
       Emacs style key escapes can be used, as in the following  example,  but
       the symbolic character names are not recognized.

              "\C-u": universal-argument
              "\C-x\C-r": re-read-init-file
              "\e[11~": "Function Key 1"

       In this example, _C_-_u is again bound to the function uunniivveerrssaall--aarrgguummeenntt.
       _C_-_x _C_-_r is bound to the function rree--rreeaadd--iinniitt--ffiillee, and _E_S_C _[ _1 _1 _~  is
       bound to insert the text ‘‘Function Key 1’’.

       The full set of GNU Emacs style escape sequences is
              \\CC--    control prefix
              \\MM--    meta prefix
              \\ee     an escape character
              \\\\     backslash
              \\""     literal "
              \\''     literal '

       In  addition  to  the GNU Emacs style escape sequences, a second set of
       backslash escapes is available:
              \\aa     alert (bell)
              \\bb     backspace
              \\dd     delete
              \\ff     form feed
              \\nn     newline
              \\rr     carriage return
              \\tt     horizontal tab
              \\vv     vertical tab
              \\_n_n_n   the eight-bit character whose value is  the  octal  value
                     _n_n_n (one to three digits)
              \\xx_H_H   the  eight-bit  character  whose value is the hexadecimal
                     value _H_H (one or two hex digits)

       When entering the text of a macro, single or double quotes must be used
       to indicate a macro definition.  Unquoted text is assumed to be a func-
       tion name.  In the macro body, the backslash  escapes  described  above
       are  expanded.   Backslash  will quote any other character in the macro
       text, including " and '.

       BBaasshh allows the current readline key bindings to be displayed or  modi-
       fied  with  the bbiinndd builtin command.  The editing mode may be switched
       during interactive use by using the --oo option to the sseett  builtin  com-
       mand (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).

   RReeaaddlliinnee VVaarriiaabblleess
       Readline has variables that can be used to further customize its behav-
       ior.  A variable may be set in the _i_n_p_u_t_r_c file with a statement of the
       form

              sseett _v_a_r_i_a_b_l_e_-_n_a_m_e _v_a_l_u_e

       Except  where  noted,  readline variables can take the values OOnn or OOffff
       (without regard to case).  Unrecognized  variable  names  are  ignored.
       When  a variable value is read, empty or null values, "on" (case-insen-
       sitive), and "1" are equivalent to OOnn.  All other values are equivalent
       to OOffff.  The variables and their default values are:

       bbeellll--ssttyyllee ((aauuddiibbllee))
              Controls  what  happens when readline wants to ring the terminal
              bell.  If set to nnoonnee, readline never rings the bell.  If set to
              vviissiibbllee,  readline  uses a visible bell if one is available.  If
              set to aauuddiibbllee, readline attempts to ring the terminal’s bell.
       bbiinndd--ttttyy--ssppeecciiaall--cchhaarrss ((OOnn))
              If set to OOnn, readline attempts to bind the  control  characters
              treated specially by the kernel’s terminal driver to their read-
              line equivalents.
       ccoommmmeenntt--bbeeggiinn ((‘‘‘‘##’’’’))
              The string that is inserted  when  the  readline  iinnsseerrtt--ccoommmmeenntt
              command is executed.  This command is bound to MM--## in emacs mode
              and to ## in vi command mode.
       ccoommpplleettiioonn--iiggnnoorree--ccaassee ((OOffff))
              If set to OOnn, readline performs filename matching and completion
              in a case-insensitive fashion.
       ccoommpplleettiioonn--pprreeffiixx--ddiissppllaayy--lleennggtthh ((00))
              The  length in characters of the common prefix of a list of pos-
              sible completions that is displayed without modification.   When
              set  to  a  value greater than zero, common prefixes longer than
              this value are replaced with an ellipsis when displaying  possi-
              ble completions.
       ccoommpplleettiioonn--qquueerryy--iitteemmss ((110000))
              This  determines when the user is queried about viewing the num-
              ber of possible completions generated  by  the  ppoossssiibbllee--ccoommppllee--
              ttiioonnss  command.  It may be set to any integer value greater than
              or equal to zero.  If the  number  of  possible  completions  is
              greater than or equal to the value of this variable, the user is
              asked whether or not he wishes to view them; otherwise they  are
              simply listed on the terminal.
       ccoonnvveerrtt--mmeettaa ((OOnn))
              If  set  to OOnn, readline will convert characters with the eighth
              bit set to an ASCII key sequence by stripping the eighth bit and
              prefixing  an  escape  character (in effect, using escape as the
              _m_e_t_a _p_r_e_f_i_x).
       ddiissaabbllee--ccoommpplleettiioonn ((OOffff))
              If set to OOnn, readline will inhibit word completion.  Completion
              characters  will  be  inserted into the line as if they had been
              mapped to sseellff--iinnsseerrtt.
       eeddiittiinngg--mmooddee ((eemmaaccss))
              Controls whether readline begins with a set of key bindings sim-
              ilar to _e_m_a_c_s or _v_i.  eeddiittiinngg--mmooddee can be set to either eemmaaccss or
              vvii.
       eecchhoo--ccoonnttrrooll--cchhaarraacctteerrss ((OOnn))
              When set to OOnn, on operating systems that indicate they  support
              it, readline echoes a character corresponding to a signal gener-
              ated from the keyboard.
       eennaabbllee--kkeeyyppaadd ((OOffff))
              When set to OOnn, readline will try to enable the application key-
              pad  when  it  is  called.  Some systems need this to enable the
              arrow keys.
       eennaabbllee--mmeettaa--kkeeyy ((OOnn))
              When set to OOnn, readline will try to enable  any  meta  modifier
              key  the  terminal claims to support when it is called.  On many
              terminals, the meta key is used to send eight-bit characters.
       eexxppaanndd--ttiillddee ((OOffff))
              If set  to  oonn,  tilde  expansion  is  performed  when  readline
              attempts word completion.
       hhiissttoorryy--pprreesseerrvvee--ppooiinntt ((OOffff))
              If  set  to  oonn, the history code attempts to place point at the
              same location on each history line retrieved with  pprreevviioouuss--hhiiss--
              ttoorryy or nneexxtt--hhiissttoorryy.
       hhiissttoorryy--ssiizzee ((00))
              Set  the  maximum number of history entries saved in the history
              list.  If set to zero, the number of entries in the history list
              is not limited.
       hhoorriizzoonnttaall--ssccrroollll--mmooddee ((OOffff))
              When  set  to  OOnn, makes readline use a single line for display,
              scrolling the input horizontally on a single screen line when it
              becomes  longer  than the screen width rather than wrapping to a
              new line.
       iinnppuutt--mmeettaa ((OOffff))
              If set to OOnn, readline will enable eight-bit input (that is,  it
              will  not  strip  the  high  bit  from the characters it reads),
              regardless of what the terminal claims it can support.  The name
              mmeettaa--ffllaagg is a synonym for this variable.
       iisseeaarrcchh--tteerrmmiinnaattoorrss ((‘‘‘‘CC--[[CC--JJ’’’’))
              The  string  of  characters that should terminate an incremental
              search without subsequently executing the character  as  a  com-
              mand.   If this variable has not been given a value, the charac-
              ters _E_S_C and _C_-_J will terminate an incremental search.
       kkeeyymmaapp ((eemmaaccss))
              Set the current readline keymap.  The set of valid keymap  names
              is  _e_m_a_c_s_,  _e_m_a_c_s_-_s_t_a_n_d_a_r_d_,  _e_m_a_c_s_-_m_e_t_a_, _e_m_a_c_s_-_c_t_l_x_, _v_i_, _v_i_-_c_o_m_-
              _m_a_n_d, and _v_i_-_i_n_s_e_r_t.  _v_i is equivalent to _v_i_-_c_o_m_m_a_n_d;  _e_m_a_c_s  is
              equivalent  to  _e_m_a_c_s_-_s_t_a_n_d_a_r_d.  The default value is _e_m_a_c_s; the
              value of eeddiittiinngg--mmooddee also affects the default keymap.
       mmaarrkk--ddiirreeccttoorriieess ((OOnn))
              If set to OOnn, completed directory names have a slash appended.
       mmaarrkk--mmooddiiffiieedd--lliinneess ((OOffff))
              If set to OOnn, history lines that have  been  modified  are  dis-
              played with a preceding asterisk (**).
       mmaarrkk--ssyymmlliinnkkeedd--ddiirreeccttoorriieess ((OOffff))
              If set to OOnn, completed names which are symbolic links to direc-
              tories  have  a  slash  appended  (subject  to  the   value   of
              mmaarrkk--ddiirreeccttoorriieess).
       mmaattcchh--hhiiddddeenn--ffiilleess ((OOnn))
              This  variable,  when  set to OOnn, causes readline to match files
              whose names begin with a  ‘.’  (hidden  files)  when  performing
              filename  completion,  unless the leading ‘.’ is supplied by the
              user in the filename to be completed.
       oouuttppuutt--mmeettaa ((OOffff))
              If set to OOnn, readline will display characters with  the  eighth
              bit set directly rather than as a meta-prefixed escape sequence.
       ppaaggee--ccoommpplleettiioonnss ((OOnn))
              If set to OOnn, readline uses an internal _m_o_r_e-like pager to  dis-
              play a screenful of possible completions at a time.
       pprriinntt--ccoommpplleettiioonnss--hhoorriizzoonnttaallllyy ((OOffff))
              If  set  to  OOnn,  readline will display completions with matches
              sorted horizontally in alphabetical order, rather than down  the
              screen.
       rreevveerrtt--aallll--aatt--nneewwlliinnee ((OOffff))
              If  set  to  oonn, readline will undo all changes to history lines
              before returning when aacccceepptt--lliinnee is executed.  By default, his-
              tory  lines  may  be  modified  and retain individual undo lists
              across calls to rreeaaddlliinnee.
       sshhooww--aallll--iiff--aammbbiigguuoouuss ((OOffff))
              This alters the default behavior of  the  completion  functions.
              If set to oonn, words which have more than one possible completion
              cause the matches to be listed immediately  instead  of  ringing
              the bell.
       sshhooww--aallll--iiff--uunnmmooddiiffiieedd ((OOffff))
              This  alters the default behavior of the completion functions in
              a fashion similar to sshhooww--aallll--iiff--aammbbiigguuoouuss.  If set to oonn, words
              which  have more than one possible completion without any possi-
              ble partial completion (the possible completions don’t  share  a
              common  prefix)  cause  the  matches  to  be  listed immediately
              instead of ringing the bell.
       sskkiipp--ccoommpplleetteedd--tteexxtt ((OOffff))
              If set to OOnn, this alters the default completion  behavior  when
              inserting  a  single match into the line.  It’s only active when
              performing completion in the middle  of  a  word.   If  enabled,
              readline  does  not  insert  characters from the completion that
              match characters after point in the  word  being  completed,  so
              portions of the word following the cursor are not duplicated.
       vviissiibbllee--ssttaattss ((OOffff))
              If  set to OOnn, a character denoting a file’s type as reported by
              _s_t_a_t(2) is appended to the filename when listing  possible  com-
              pletions.

   RReeaaddlliinnee CCoonnddiittiioonnaall CCoonnssttrruuccttss
       Readline  implements  a  facility  similar in spirit to the conditional
       compilation features of the C preprocessor which  allows  key  bindings
       and  variable  settings  to be performed as the result of tests.  There
       are four parser directives used.

       $$iiff    The $$iiff construct allows bindings to be made based on the  edit-
              ing  mode,  the  terminal  being  used, or the application using
              readline.  The text of the test extends to the end of the  line;
              no characters are required to isolate it.

              mmooddee   The  mmooddee==  form  of  the  $$iiff  directive is used to test
                     whether readline is in emacs or vi  mode.   This  may  be
                     used  in  conjunction  with  the  sseett kkeeyymmaapp command, for
                     instance, to  set  bindings  in  the  _e_m_a_c_s_-_s_t_a_n_d_a_r_d  and
                     _e_m_a_c_s_-_c_t_l_x  keymaps  only  if readline is starting out in
                     emacs mode.

              tteerrmm   The tteerrmm== form may be used to  include  terminal-specific
                     key bindings, perhaps to bind the key sequences output by
                     the terminal’s function keys.  The word on the right side
                     of the == is tested against the both full name of the ter-
                     minal and the portion of the  terminal  name  before  the
                     first  --.  This allows _s_u_n to match both _s_u_n and _s_u_n_-_c_m_d,
                     for instance.

              aapppplliiccaattiioonn
                     The aapppplliiccaattiioonn construct is used to include application-
                     specific  settings.   Each  program  using  the  readline
                     library sets the _a_p_p_l_i_c_a_t_i_o_n _n_a_m_e, and an  initialization
                     file can test for a particular value.  This could be used
                     to bind key sequences to functions useful for a  specific
                     program.   For instance, the following command adds a key
                     sequence that quotes the  current  or  previous  word  in
                     Bash:

                     $$iiff Bash
                     # Quote the current or previous word
                     "\C-xq": "\eb\"\ef\""
                     $$eennddiiff

       $$eennddiiff This command, as seen in the previous example, terminates an $$iiff
              command.

       $$eellssee  Commands in this branch of the $$iiff directive are executed if the
              test fails.

       $$iinncclluuddee
              This  directive takes a single filename as an argument and reads
              commands  and  bindings  from  that  file.   For  example,   the
              following directive would read _/_e_t_c_/_i_n_p_u_t_r_c:

              $$iinncclluuddee  _/_e_t_c_/_i_n_p_u_t_r_c

   SSeeaarrcchhiinngg
       Readline  provides  commands  for searching through the command history
       (see HHIISSTTOORRYY below) for lines containing a specified string.  There are
       two search modes: _i_n_c_r_e_m_e_n_t_a_l and _n_o_n_-_i_n_c_r_e_m_e_n_t_a_l.

       Incremental  searches  begin  before  the  user has finished typing the
       search string.  As each character of the search string is typed,  read-
       line displays the next entry from the history matching the string typed
       so far.  An incremental search requires  only  as  many  characters  as
       needed  to  find  the desired history entry.  The characters present in
       the value of the iisseeaarrcchh--tteerrmmiinnaattoorrss variable are used to terminate  an
       incremental search.  If that variable has not been assigned a value the
       Escape and Control-J characters will terminate an  incremental  search.
       Control-G  will  abort  an  incremental search and restore the original
       line.  When the search is terminated, the history entry containing  the
       search string becomes the current line.

       To  find  other matching entries in the history list, type Control-S or
       Control-R as appropriate.  This will search backward or forward in  the
       history  for  the  next  entry matching the search string typed so far.
       Any other key sequence bound to a readline command will  terminate  the
       search  and  execute that command.  For instance, a _n_e_w_l_i_n_e will termi-
       nate the search and accept the line, thereby executing the command from
       the history list.

       Readline remembers the last incremental search string.  If two Control-
       Rs are typed without any intervening characters defining a  new  search
       string, any remembered search string is used.

       Non-incremental  searches read the entire search string before starting
       to search for matching history lines.  The search string may  be  typed
       by the user or be part of the contents of the current line.

   RReeaaddlliinnee CCoommmmaanndd NNaammeess
       The  following  is  a list of the names of the commands and the default
       key sequences to which they are bound.  Command names without an accom-
       panying key sequence are unbound by default.  In the following descrip-
       tions, _p_o_i_n_t refers to the current cursor position, and _m_a_r_k refers  to
       a  cursor position saved by the sseett--mmaarrkk command.  The text between the
       point and mark is referred to as the _r_e_g_i_o_n.

   CCoommmmaannddss ffoorr MMoovviinngg
       bbeeggiinnnniinngg--ooff--lliinnee ((CC--aa))
              Move to the start of the current line.
       eenndd--ooff--lliinnee ((CC--ee))
              Move to the end of the line.
       ffoorrwwaarrdd--cchhaarr ((CC--ff))
              Move forward a character.
       bbaacckkwwaarrdd--cchhaarr ((CC--bb))
              Move back a character.
       ffoorrwwaarrdd--wwoorrdd ((MM--ff))
              Move forward to the end of the next word.  Words are composed of
              alphanumeric characters (letters and digits).
       bbaacckkwwaarrdd--wwoorrdd ((MM--bb))
              Move  back  to the start of the current or previous word.  Words
              are composed of alphanumeric characters (letters and digits).
       sshheellll--ffoorrwwaarrdd--wwoorrdd
              Move forward to the end of the next word.  Words  are  delimited
              by non-quoted shell metacharacters.
       sshheellll--bbaacckkwwaarrdd--wwoorrdd
              Move  back  to the start of the current or previous word.  Words
              are delimited by non-quoted shell metacharacters.
       cclleeaarr--ssccrreeeenn ((CC--ll))
              Clear the screen leaving the current line  at  the  top  of  the
              screen.   With  an  argument,  refresh  the current line without
              clearing the screen.
       rreeddrraaww--ccuurrrreenntt--lliinnee
              Refresh the current line.

   CCoommmmaannddss ffoorr MMaanniippuullaattiinngg tthhee HHiissttoorryy
       aacccceepptt--lliinnee ((NNeewwlliinnee,, RReettuurrnn))
              Accept the line regardless of where the cursor is.  If this line
              is  non-empty, add it to the history list according to the state
              of the HHIISSTTCCOONNTTRROOLL variable.  If the line is a modified  history
              line, then restore the history line to its original state.
       pprreevviioouuss--hhiissttoorryy ((CC--pp))
              Fetch the previous command from the history list, moving back in
              the list.
       nneexxtt--hhiissttoorryy ((CC--nn))
              Fetch the next command from the history list, moving forward  in
              the list.
       bbeeggiinnnniinngg--ooff--hhiissttoorryy ((MM--<<))
              Move to the first line in the history.
       eenndd--ooff--hhiissttoorryy ((MM-->>))
              Move  to  the end of the input history, i.e., the line currently
              being entered.
       rreevveerrssee--sseeaarrcchh--hhiissttoorryy ((CC--rr))
              Search backward starting at the current  line  and  moving  ‘up’
              through  the  history  as  necessary.   This  is  an incremental
              search.
       ffoorrwwaarrdd--sseeaarrcchh--hhiissttoorryy ((CC--ss))
              Search forward starting at the current line  and  moving  ‘down’
              through  the  history  as  necessary.   This  is  an incremental
              search.
       nnoonn--iinnccrreemmeennttaall--rreevveerrssee--sseeaarrcchh--hhiissttoorryy ((MM--pp))
              Search backward through the history starting at the current line
              using  a  non-incremental  search  for  a string supplied by the
              user.
       nnoonn--iinnccrreemmeennttaall--ffoorrwwaarrdd--sseeaarrcchh--hhiissttoorryy ((MM--nn))
              Search forward  through  the  history  using  a  non-incremental
              search for a string supplied by the user.
       hhiissttoorryy--sseeaarrcchh--ffoorrwwaarrdd
              Search  forward through the history for the string of characters
              between the start of the current line and the point.  This is  a
              non-incremental search.
       hhiissttoorryy--sseeaarrcchh--bbaacckkwwaarrdd
              Search backward through the history for the string of characters
              between the start of the current line and the point.  This is  a
              non-incremental search.
       yyaannkk--nntthh--aarrgg ((MM--CC--yy))
              Insert  the  first argument to the previous command (usually the
              second word on the previous line) at point.  With an argument _n,
              insert  the _nth word from the previous command (the words in the
              previous command  begin  with  word  0).   A  negative  argument
              inserts the _nth word from the end of the previous command.  Once
              the argument _n is computed, the argument is extracted as if  the
              "!_n" history expansion had been specified.
       yyaannkk--llaasstt--aarrgg ((MM--..,, MM--__))
              Insert  the last argument to the previous command (the last word
              of the  previous  history  entry).   With  an  argument,  behave
              exactly  like  yyaannkk--nntthh--aarrgg.   Successive calls to yyaannkk--llaasstt--aarrgg
              move back through the history list, inserting the last  argument
              of each line in turn.  The history expansion facilities are used
              to extract the last argument, as if the "!$"  history  expansion
              had been specified.
       sshheellll--eexxppaanndd--lliinnee ((MM--CC--ee))
              Expand the line as the shell does.  This performs alias and his-
              tory expansion as well as all of the shell word expansions.  See
              HHIISSTTOORRYY  EEXXPPAANNSSIIOONN below for a description of history expansion.
       hhiissttoorryy--eexxppaanndd--lliinnee ((MM--^^))
              Perform history expansion on  the  current  line.   See  HHIISSTTOORRYY
              EEXXPPAANNSSIIOONN below for a description of history expansion.
       mmaaggiicc--ssppaaccee
              Perform  history  expansion  on  the  current  line and insert a
              space.  See HHIISSTTOORRYY EEXXPPAANNSSIIOONN below for a description of history
              expansion.
       aalliiaass--eexxppaanndd--lliinnee
              Perform  alias expansion on the current line.  See AALLIIAASSEESS above
              for a description of alias expansion.
       hhiissttoorryy--aanndd--aalliiaass--eexxppaanndd--lliinnee
              Perform history and alias expansion on the current line.
       iinnsseerrtt--llaasstt--aarrgguummeenntt ((MM--..,, MM--__))
              A synonym for yyaannkk--llaasstt--aarrgg.
       ooppeerraattee--aanndd--ggeett--nneexxtt ((CC--oo))
              Accept the current line for execution and fetch  the  next  line
              relative  to the current line from the history for editing.  Any
              argument is ignored.
       eeddiitt--aanndd--eexxeeccuuttee--ccoommmmaanndd ((CC--xxCC--ee))
              Invoke an editor on the current command line,  and  execute  the
              result  as  shell  commands.   BBaasshh  attempts to invoke $$VVIISSUUAALL,
              $$EEDDIITTOORR, and _e_m_a_c_s as the editor, in that order.

   CCoommmmaannddss ffoorr CChhaannggiinngg TTeexxtt
       ddeelleettee--cchhaarr ((CC--dd))
              Delete the character at point.  If point is at the beginning  of
              the  line,  there  are  no  characters in the line, and the last
              character typed was not bound to ddeelleettee--cchhaarr, then return EEOOFF.
       bbaacckkwwaarrdd--ddeelleettee--cchhaarr ((RRuubboouutt))
              Delete the character behind the cursor.  When  given  a  numeric
              argument, save the deleted text on the kill ring.
       ffoorrwwaarrdd--bbaacckkwwaarrdd--ddeelleettee--cchhaarr
              Delete  the  character under the cursor, unless the cursor is at
              the end of the line, in which case the character behind the cur-
              sor is deleted.
       qquuootteedd--iinnsseerrtt ((CC--qq,, CC--vv))
              Add  the next character typed to the line verbatim.  This is how
              to insert characters like CC--qq, for example.
       ttaabb--iinnsseerrtt ((CC--vv TTAABB))
              Insert a tab character.
       sseellff--iinnsseerrtt ((aa,, bb,, AA,, 11,, !!,, ......))
              Insert the character typed.
       ttrraannssppoossee--cchhaarrss ((CC--tt))
              Drag the character before point forward over  the  character  at
              point,  moving point forward as well.  If point is at the end of
              the line, then this transposes the two characters before  point.
              Negative arguments have no effect.
       ttrraannssppoossee--wwoorrddss ((MM--tt))
              Drag  the  word  before  point past the word after point, moving
              point over that word as well.  If point is at  the  end  of  the
              line, this transposes the last two words on the line.
       uuppccaassee--wwoorrdd ((MM--uu))
              Uppercase  the  current  (or  following)  word.  With a negative
              argument, uppercase the previous word, but do not move point.
       ddoowwnnccaassee--wwoorrdd ((MM--ll))
              Lowercase the current (or  following)  word.   With  a  negative
              argument, lowercase the previous word, but do not move point.
       ccaappiittaalliizzee--wwoorrdd ((MM--cc))
              Capitalize  the  current  (or  following) word.  With a negative
              argument, capitalize the previous word, but do not move point.
       oovveerrwwrriittee--mmooddee
              Toggle overwrite mode.  With an explicit positive numeric  argu-
              ment, switches to overwrite mode.  With an explicit non-positive
              numeric argument, switches to insert mode.  This command affects
              only  eemmaaccss mode; vvii mode does overwrite differently.  Each call
              to _r_e_a_d_l_i_n_e_(_) starts in insert mode.  In overwrite mode, charac-
              ters  bound to sseellff--iinnsseerrtt replace the text at point rather than
              pushing the text  to  the  right.   Characters  bound  to  bbaacckk--
              wwaarrdd--ddeelleettee--cchhaarr  replace  the  character  before  point  with a
              space.  By default, this command is unbound.

   KKiilllliinngg aanndd YYaannkkiinngg
       kkiillll--lliinnee ((CC--kk))
              Kill the text from point to the end of the line.
       bbaacckkwwaarrdd--kkiillll--lliinnee ((CC--xx RRuubboouutt))
              Kill backward to the beginning of the line.
       uunniixx--lliinnee--ddiissccaarrdd ((CC--uu))
              Kill backward from point to the  beginning  of  the  line.   The
              killed text is saved on the kill-ring.
       kkiillll--wwhhoollee--lliinnee
              Kill  all  characters on the current line, no matter where point
              is.
       kkiillll--wwoorrdd ((MM--dd))
              Kill from point to the end of the current word,  or  if  between
              words,  to  the  end  of the next word.  Word boundaries are the
              same as those used by ffoorrwwaarrdd--wwoorrdd.
       bbaacckkwwaarrdd--kkiillll--wwoorrdd ((MM--RRuubboouutt))
              Kill the word behind point.  Word boundaries  are  the  same  as
              those used by bbaacckkwwaarrdd--wwoorrdd.
       sshheellll--kkiillll--wwoorrdd ((MM--dd))
              Kill  from  point  to the end of the current word, or if between
              words, to the end of the next word.   Word  boundaries  are  the
              same as those used by sshheellll--ffoorrwwaarrdd--wwoorrdd.
       sshheellll--bbaacckkwwaarrdd--kkiillll--wwoorrdd ((MM--RRuubboouutt))
              Kill  the  word  behind  point.  Word boundaries are the same as
              those used by sshheellll--bbaacckkwwaarrdd--wwoorrdd.
       uunniixx--wwoorrdd--rruubboouutt ((CC--ww))
              Kill the word behind point, using white space as a  word  bound-
              ary.  The killed text is saved on the kill-ring.
       uunniixx--ffiilleennaammee--rruubboouutt
              Kill  the  word  behind  point,  using white space and the slash
              character as the word boundaries.  The killed text is  saved  on
              the kill-ring.
       ddeelleettee--hhoorriizzoonnttaall--ssppaaccee ((MM--\\))
              Delete all spaces and tabs around point.
       kkiillll--rreeggiioonn
              Kill the text in the current region.
       ccooppyy--rreeggiioonn--aass--kkiillll
              Copy the text in the region to the kill buffer.
       ccooppyy--bbaacckkwwaarrdd--wwoorrdd
              Copy  the word before point to the kill buffer.  The word bound-
              aries are the same as bbaacckkwwaarrdd--wwoorrdd.
       ccooppyy--ffoorrwwaarrdd--wwoorrdd
              Copy the word following point to  the  kill  buffer.   The  word
              boundaries are the same as ffoorrwwaarrdd--wwoorrdd.
       yyaannkk ((CC--yy))
              Yank the top of the kill ring into the buffer at point.
       yyaannkk--ppoopp ((MM--yy))
              Rotate  the kill ring, and yank the new top.  Only works follow-
              ing yyaannkk or yyaannkk--ppoopp.

   NNuummeerriicc AArrgguummeennttss
       ddiiggiitt--aarrgguummeenntt ((MM--00,, MM--11,, ......,, MM----))
              Add this digit to the argument already accumulating, or start  a
              new argument.  M-- starts a negative argument.
       uunniivveerrssaall--aarrgguummeenntt
              This  is another way to specify an argument.  If this command is
              followed by one or more digits, optionally with a leading  minus
              sign,  those digits define the argument.  If the command is fol-
              lowed by digits, executing  uunniivveerrssaall--aarrgguummeenntt  again  ends  the
              numeric  argument, but is otherwise ignored.  As a special case,
              if this command is immediately followed by a character  that  is
              neither  a  digit or minus sign, the argument count for the next
              command is multiplied by four.  The argument count is  initially
              one,  so  executing this function the first time makes the argu-
              ment count four, a second time makes the argument count sixteen,
              and so on.

   CCoommpplleettiinngg
       ccoommpplleettee ((TTAABB))
              Attempt  to  perform  completion on the text before point.  BBaasshh
              attempts completion treating the text as a variable (if the text
              begins  with  $$), username (if the text begins with ~~), hostname
              (if the text begins with @@), or command (including  aliases  and
              functions) in turn.  If none of these produces a match, filename
              completion is attempted.
       ppoossssiibbllee--ccoommpplleettiioonnss ((MM--??))
              List the possible completions of the text before point.
       iinnsseerrtt--ccoommpplleettiioonnss ((MM--**))
              Insert all completions of the text before point that would  have
              been generated by ppoossssiibbllee--ccoommpplleettiioonnss.
       mmeennuu--ccoommpplleettee
              Similar  to ccoommpplleettee, but replaces the word to be completed with
              a single match from the list of possible completions.   Repeated
              execution  of  mmeennuu--ccoommpplleettee  steps through the list of possible
              completions, inserting each match in turn.  At the  end  of  the
              list of completions, the bell is rung (subject to the setting of
              bbeellll--ssttyyllee) and the original text is restored.  An argument of _n
              moves  _n  positions  forward  in the list of matches; a negative
              argument may be used to move backward through  the  list.   This
              command  is  intended  to  be  bound  to  TTAABB, but is unbound by
              default.cc
       mmeennuu--ccoommpplleettee--kkrrdd
              Identicwwal to mmeennuu--ccoommpplleettee, but moves backward through the  list
              of  possible  completions,  as if mmeennuu--ccoommpplleettee had been given a
              negative argument.  This command is unbound by default.
       ddeelleettee--cchhaarr--oorr--lliisstt
              Deletes the character under the cursor if not at  the  beginning
              or  end  of  the  line (like ddeelleettee--cchhaarr).  If at the end of the
              line, behaves identically to ppoossssiibbllee--ccoommpplleettiioonnss.  This command
              is unbound by default.
       ccoommpplleettee--ffiilleennaammee ((MM--//))
              Attempt filename completion on the text before point.
       ppoossssiibbllee--ffiilleennaammee--ccoommpplleettiioonnss ((CC--xx //))
              List the possible completions of the text before point, treating
              it as a filename.
       ccoommpplleettee--uusseerrnnaammee ((MM--~~))
              Attempt completion on the text before point, treating  it  as  a
              username.
       ppoossssiibbllee--uusseerrnnaammee--ccoommpplleettiioonnss ((CC--xx ~~))
              List the possible completions of the text before point, treating
              it as a username.
       ccoommpplleettee--vvaarriiaabbllee ((MM--$$))
              Attempt completion on the text before point, treating  it  as  a
              shell variable.
       ppoossssiibbllee--vvaarriiaabbllee--ccoommpplleettiioonnss ((CC--xx $$))
              List the possible completions of the text before point, treating
              it as a shell variable.
       ccoommpplleettee--hhoossttnnaammee ((MM--@@))
              Attempt completion on the text before point, treating  it  as  a
              hostname.
       ppoossssiibbllee--hhoossttnnaammee--ccoommpplleettiioonnss ((CC--xx @@))
              List the possible completions of the text before point, treating
              it as a hostname.
       ccoommpplleettee--ccoommmmaanndd ((MM--!!))
              Attempt completion on the text before point, treating  it  as  a
              command  name.   Command  completion  attempts to match the text
              against  aliases,  reserved  words,   shell   functions,   shell
              builtins, and finally executable filenames, in that order.
       ppoossssiibbllee--ccoommmmaanndd--ccoommpplleettiioonnss ((CC--xx !!))
              List the possible completions of the text before point, treating
              it as a command name.
       ddyynnaammiicc--ccoommpplleettee--hhiissttoorryy ((MM--TTAABB))
              Attempt completion on the text before point, comparing the  text
              against  lines  from  the  history  list for possible completion
              matches.
       ddaabbbbrreevv--eexxppaanndd
              Attempt menu completion on the text before point, comparing  the
              text against lines from the history list for possible completion
              matches.
       ccoommpplleettee--iinnttoo--bbrraacceess ((MM--{{))
              Perform filename completion and insert the list of possible com-
              pletions  enclosed within braces so the list is available to the
              shell (see BBrraaccee EExxppaannssiioonn above).

   KKeeyybbooaarrdd MMaaccrrooss
       ssttaarrtt--kkbbdd--mmaaccrroo ((CC--xx (())
              Begin saving the characters  typed  into  the  current  keyboard
              macro.
       eenndd--kkbbdd--mmaaccrroo ((CC--xx ))))
              Stop saving the characters typed into the current keyboard macro
              and store the definition.
       ccaallll--llaasstt--kkbbdd--mmaaccrroo ((CC--xx ee))
              Re-execute the last keyboard macro defined, by making the  char-
              acters in the macro appear as if typed at the keyboard.

   MMiisscceellllaanneeoouuss
       rree--rreeaadd--iinniitt--ffiillee ((CC--xx CC--rr))
              Read  in  the  contents of the _i_n_p_u_t_r_c file, and incorporate any
              bindings or variable assignments found there.
       aabboorrtt ((CC--gg))
              Abort the current editing command and ring the  terminal’s  bell
              (subject to the setting of bbeellll--ssttyyllee).
       ddoo--uuppppeerrccaassee--vveerrssiioonn ((MM--aa,, MM--bb,, MM--_x,, ......))
              If  the  metafied character _x is lowercase, run the command that
              is bound to the corresponding uppercase character.
       pprreeffiixx--mmeettaa ((EESSCC))
              Metafy the next character typed.  EESSCC ff is equivalent to MMeettaa--ff.
       uunnddoo ((CC--__,, CC--xx CC--uu))
              Incremental undo, separately remembered for each line.
       rreevveerrtt--lliinnee ((MM--rr))
              Undo  all changes made to this line.  This is like executing the
              uunnddoo command enough times to return  the  line  to  its  initial
              state.
       ttiillddee--eexxppaanndd ((MM--&&))
              Perform tilde expansion on the current word.
       sseett--mmaarrkk ((CC--@@,, MM--<<ssppaaccee>>))
              Set  the  mark to the point.  If a numeric argument is supplied,
              the mark is set to that position.
       eexxcchhaannggee--ppooiinntt--aanndd--mmaarrkk ((CC--xx CC--xx))
              Swap the point with the mark.  The current  cursor  position  is
              set  to the saved position, and the old cursor position is saved
              as the mark.
       cchhaarraacctteerr--sseeaarrcchh ((CC--]]))
              A character is read and point is moved to the next occurrence of
              that  character.   A negative count searches for previous occur-
              rences.
       cchhaarraacctteerr--sseeaarrcchh--bbaacckkwwaarrdd ((MM--CC--]]))
              A character is read and point is moved to  the  previous  occur-
              rence  of  that character.  A negative count searches for subse-
              quent occurrences.
       sskkiipp--ccssii--sseeqquueennccee (())
              Read enough characters to consume a multi-key sequence  such  as
              those  defined for keys like Home and End.  Such sequences begin
              with a Control Sequence Indicator (CSI), usually ESC-[.  If this
              sequence  is  bound  to "\[", keys producing such sequences will
              have no effect unless explicitly bound to  a  readline  command,
              instead  of  inserting stray characters into the editing buffer.
              This is unbound by default, but usually bound to ESC-[.
       iinnsseerrtt--ccoommmmeenntt ((MM--##))
              Without a numeric argument,  the  value  of  the  readline  ccoomm--
              mmeenntt--bbeeggiinn  variable is inserted at the beginning of the current
              line.  If a numeric argument is supplied, this command acts as a
              toggle:   if  the characters at the beginning of the line do not
              match the value of ccoommmmeenntt--bbeeggiinn, the value is inserted,  other-
              wise the characters in ccoommmmeenntt--bbeeggiinn are deleted from the begin-
              ning of the line.  In either case, the line is accepted as if  a
              newline  had  been  typed.   The  default value of ccoommmmeenntt--bbeeggiinn
              causes this command to make the current line  a  shell  comment.
              If  a  numeric  argument  causes  the  comment  character  to be
              removed, the line will be executed by the shell.
       gglloobb--ccoommpplleettee--wwoorrdd ((MM--gg))
              The word before point is  treated  as  a  pattern  for  pathname
              expansion,  with  an asterisk implicitly appended.  This pattern
              is used to generate a list of matching file names  for  possible
              completions.
       gglloobb--eexxppaanndd--wwoorrdd ((CC--xx **))
              The  word  before  point  is  treated  as a pattern for pathname
              expansion, and the list of  matching  file  names  is  inserted,
              replacing  the  word.   If  a  numeric  argument is supplied, an
              asterisk is appended before pathname expansion.
       gglloobb--lliisstt--eexxppaannssiioonnss ((CC--xx gg))
              The list  of  expansions  that  would  have  been  generated  by
              gglloobb--eexxppaanndd--wwoorrdd  is  displayed,  and the line is redrawn.  If a
              numeric argument is supplied, an  asterisk  is  appended  before
              pathname expansion.
       dduummpp--ffuunnccttiioonnss
              Print  all  of the functions and their key bindings to the read-
              line output stream.  If a  numeric  argument  is  supplied,  the
              output is formatted in such a way that it can be made part of an
              _i_n_p_u_t_r_c file.
       dduummpp--vvaarriiaabblleess
              Print all of the settable readline variables and their values to
              the  readline output stream.  If a numeric argument is supplied,
              the output is formatted in such a way that it can be  made  part
              of an _i_n_p_u_t_r_c file.
       dduummpp--mmaaccrrooss
              Print  all of the readline key sequences bound to macros and the
              strings they output.  If a numeric  argument  is  supplied,  the
              output is formatted in such a way that it can be made part of an
              _i_n_p_u_t_r_c file.
       ddiissppllaayy--sshheellll--vveerrssiioonn ((CC--xx CC--vv))
              Display version information about the current instance of  bbaasshh.

   PPrrooggrraammmmaabbllee CCoommpplleettiioonn
       When  word  completion  is  attempted  for an argument to a command for
       which a completion specification (a _c_o_m_p_s_p_e_c) has  been  defined  using
       the  ccoommpplleettee  builtin  (see  SSHHEELLLL  BBUUIILLTTIINN  CCOOMMMMAANNDDSS below), the pro-
       grammable completion facilities are invoked.

       First, the command name is identified.  If  the  command  word  is  the
       empty  string (completion attempted at the beginning of an empty line),
       any compspec defined with the --EE option to  ccoommpplleettee  is  used.   If  a
       compspec  has  been  defined  for that command, the compspec is used to
       generate the list of possible completions for the word.  If the command
       word  is  a full pathname, a compspec for the full pathname is searched
       for first.  If no compspec is found for the full pathname,  an  attempt
       is  made  to find a compspec for the portion following the final slash.
       If those searches to not result in a  compspec,  any  compspec  defined
       with the --DD option to ccoommpplleettee is used as the default.

       Once  a  compspec  has  been  found, it is used to generate the list of
       matching words.  If a compspec is not found, the default  bbaasshh  comple-
       tion as described above under CCoommpplleettiinngg is performed.

       First,  the  actions  specified by the compspec are used.  Only matches
       which are prefixed by the word being completed are returned.  When  the
       --ff  or --dd option is used for filename or directory name completion, the
       shell variable FFIIGGNNOORREE is used to filter the matches.

       Any completions specified by a pathname expansion  pattern  to  the  --GG
       option are generated next.  The words generated by the pattern need not
       match the word being completed.  The GGLLOOBBIIGGNNOORREE shell variable  is  not
       used to filter the matches, but the FFIIGGNNOORREE variable is used.

       Next,  the string specified as the argument to the --WW option is consid-
       ered.  The string is first split using the characters in the  IIFFSS  spe-
       cial  variable  as delimiters.  Shell quoting is honored.  Each word is
       then expanded using brace expansion,  tilde  expansion,  parameter  and
       variable  expansion, command substitution, and arithmetic expansion, as
       described above under EEXXPPAANNSSIIOONN.  The results are split using the rules
       described above under WWoorrdd SSpplliittttiinngg.  The results of the expansion are
       prefix-matched against the word being completed, and the matching words
       become the possible completions.

       After  these matches have been generated, any shell function or command
       specified with the --FF and --CC options is invoked.  When the  command  or
       function is invoked, the CCOOMMPP__LLIINNEE, CCOOMMPP__PPOOIINNTT, CCOOMMPP__KKEEYY, and CCOOMMPP__TTYYPPEE
       variables are assigned values as described above under SShheellll VVaarriiaabblleess.
       If  a  shell  function  is being invoked, the CCOOMMPP__WWOORRDDSS and CCOOMMPP__CCWWOORRDD
       variables are also set.  When the function or command is  invoked,  the
       first  argument  is  the  name of the command whose arguments are being
       completed, the second argument is the word  being  completed,  and  the
       third  argument  is  the word preceding the word being completed on the
       current command  line.   No  filtering  of  the  generated  completions
       against  the word being completed is performed; the function or command
       has complete freedom in generating the matches.

       Any function specified with --FF is invoked first.  The function may  use
       any  of  the  shell facilities, including the ccoommppggeenn builtin described
       below, to generate the matches.  It must put the  possible  completions
       in the CCOOMMPPRREEPPLLYY array variable.

       Next,  any  command specified with the --CC option is invoked in an envi-
       ronment equivalent to command substitution.  It should print a list  of
       completions,  one  per  line, to the standard output.  Backslash may be
       used to escape a newline, if necessary.

       After all of the possible completions are generated, any filter  speci-
       fied  with  the --XX option is applied to the list.  The filter is a pat-
       tern as used for pathname expansion; a && in  the  pattern  is  replaced
       with  the text of the word being completed.  A literal && may be escaped
       with a backslash; the backslash is removed before attempting  a  match.
       Any  completion that matches the pattern will be removed from the list.
       A leading !! negates the pattern; in this case any completion not match-
       ing the pattern will be removed.

       Finally, any prefix and suffix specified with the --PP and --SS options are
       added to each member of the completion list, and the result is returned
       to the readline completion code as the list of possible completions.

       If  the previously-applied actions do not generate any matches, and the
       --oo ddiirrnnaammeess option was supplied  to  ccoommpplleettee  when  the  compspec  was
       defined, directory name completion is attempted.

       If  the  --oo  pplluussddiirrss option was supplied to ccoommpplleettee when the compspec
       was defined, directory name completion is attempted and any matches are
       added to the results of the other actions.

       By  default,  if a compspec is found, whatever it generates is returned
       to the completion code as the full set of  possible  completions.   The
       default bbaasshh completions are not attempted, and the readline default of
       filename completion is disabled.  If the --oo bbaasshhddeeffaauulltt option was sup-
       plied  to ccoommpplleettee when the compspec was defined, the bbaasshh default com-
       pletions are attempted if the compspec generates no matches.  If the --oo
       ddeeffaauulltt  option was supplied to ccoommpplleettee when the compspec was defined,
       readline’s default completion will be performed if the  compspec  (and,
       if attempted, the default bbaasshh completions) generate no matches.

       When  a  compspec  indicates that directory name completion is desired,
       the programmable completion functions force readline to append a  slash
       to  completed names which are symbolic links to directories, subject to
       the value of the mmaarrkk--ddiirreeccttoorriieess readline variable, regardless of  the
       setting of the mmaarrkk--ssyymmlliinnkkeedd--ddiirreeccttoorriieess readline variable.

       There  is  some support for dynamically modifying completions.  This is
       most useful when used in combination with a default  completion  speci-
       fied  with  ccoommpplleettee --DD.  It’s possible for shell functions executed as
       completion handlers to indicate that completion should  be  retried  by
       returning  an exit status of 124.  If a shell function returns 124, and
       changes the compspec associated with the command on which completion is
       being  attempted  (supplied  as the first argument when the function is
       executed), programmable completion restarts from the beginning, with an
       attempt to find a compspec for that command.  This allows a set of com-
       pletions to be built dynamically as  completion  is  attempted,  rather
       than being loaded all at once.

       For  instance, assuming that there is a library of compspecs, each kept
       in a file corresponding to the  name  of  the  command,  the  following
       default completion function would load completions dynamically:

       _completion_loader()
       {
            . "/etc/bash_completion.d/$1.sh" >/dev/null 2>&1 && return 124
       }
       complete -D -F _completion_loader


HHIISSTTOORRYY
       When  the  --oo  hhiissttoorryy  option to the sseett builtin is enabled, the shell
       provides access to the _c_o_m_m_a_n_d _h_i_s_t_o_r_y, the list of commands previously
       typed.   The  value  of  the HHIISSTTSSIIZZEE variable is used as the number of
       commands to save in a history list.  The text of the last HHIISSTTSSIIZZEE com-
       mands  (default  500)  is  saved.  The shell stores each command in the
       history list prior to parameter and variable expansion  (see  EEXXPPAANNSSIIOONN
       above)  but after history expansion is performed, subject to the values
       of the shell variables HHIISSTTIIGGNNOORREE and HHIISSTTCCOONNTTRROOLL.

       On startup, the history is initialized from the file named by the vari-
       able  HHIISSTTFFIILLEE  (default _~_/_._b_a_s_h___h_i_s_t_o_r_y).  The file named by the value
       of HHIISSTTFFIILLEE is truncated, if necessary, to contain  no  more  than  the
       number  of lines specified by the value of HHIISSTTFFIILLEESSIIZZEE.  When the his-
       tory file is read, lines beginning with the history  comment  character
       followed  immediately  by a digit are interpreted as timestamps for the
       preceding history line.   These  timestamps  are  optionally  displayed
       depending  on the value of the HHIISSTTTTIIMMEEFFOORRMMAATT variable.  When an inter-
       active shell exits, the last $$HHIISSTTSSIIZZEE lines are copied from  the  his-
       tory list to $$HHIISSTTFFIILLEE.  If the hhiissttaappppeenndd shell option is enabled (see
       the description of sshhoopptt under SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below), the lines
       are  appended  to the history file, otherwise the history file is over-
       written.  If HHIISSTTFFIILLEE is unset, or if the history file  is  unwritable,
       the  history is not saved.  If the HHIISSTTTTIIMMEEFFOORRMMAATT variable is set, time
       stamps are written to the history file, marked with the history comment
       character,  so  they may be preserved across shell sessions.  This uses
       the history comment character to distinguish timestamps from other his-
       tory lines.  After saving the history, the history file is truncated to
       contain no more than HHIISSTTFFIILLEESSIIZZEE lines.  If HHIISSTTFFIILLEESSIIZZEE is  not  set,
       no truncation is performed.

       The  builtin  command ffcc (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below) may be used
       to list or edit and re-execute a portion of the history list.  The hhiiss--
       ttoorryy  builtin  may  be  used  to display or modify the history list and
       manipulate the history file.  When using command-line  editing,  search
       commands  are available in each editing mode that provide access to the
       history list.

       The shell allows control over which commands are saved on  the  history
       list.  The HHIISSTTCCOONNTTRROOLL and HHIISSTTIIGGNNOORREE variables may be set to cause the
       shell to save only a subset of the commands entered.  The ccmmddhhiisstt shell
       option,  if enabled, causes the shell to attempt to save each line of a
       multi-line command in the same history entry, adding  semicolons  where
       necessary  to preserve syntactic correctness.  The lliitthhiisstt shell option
       causes the shell to save the command with embedded newlines instead  of
       semicolons.  See the description of the sshhoopptt builtin below under SSHHEELLLL
       BBUUIILLTTIINN  CCOOMMMMAANNDDSS  for  information  on  setting  and  unsetting  shell
       options.

HHIISSTTOORRYY EEXXPPAANNSSIIOONN
       The  shell  supports a history expansion feature that is similar to the
       history expansion in ccsshh..  This section describes what syntax  features
       are  available.   This  feature  is  enabled by default for interactive
       shells, and can be disabled using the ++HH option to the sseett builtin com-
       mand (see SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS below).  Non-interactive shells do not
       perform history expansion by default.

       History expansions introduce words from the history list into the input
       stream,  making  it  easy to repeat commands, insert the arguments to a
       previous command into the current input line, or fix errors in previous
       commands quickly.

       History  expansion  is  performed  immediately after a complete line is
       read, before the shell breaks it into words.  It  takes  place  in  two
       parts.   The  first is to determine which line from the history list to
       use during substitution.  The second is to select portions of that line
       for inclusion into the current one.  The line selected from the history
       is the _e_v_e_n_t, and the portions of that line that  are  acted  upon  are
       _w_o_r_d_s.   Various  _m_o_d_i_f_i_e_r_s  are  available  to manipulate the selected
       words.  The line is broken into words in the same fashion as when read-
       ing  input, so that several _m_e_t_a_c_h_a_r_a_c_t_e_r-separated words surrounded by
       quotes are considered one word.  History expansions are  introduced  by
       the  appearance  of  the  history  expansion  character,  which is !! by
       default.  Only backslash (\\) and single quotes can  quote  the  history
       expansion character.

       Several  characters inhibit history expansion if found immediately fol-
       lowing the history expansion character, even if it is unquoted:  space,
       tab,  newline,  carriage return, and ==.  If the eexxttgglloobb shell option is
       enabled, (( will also inhibit expansion.

       Several shell options settable with the sshhoopptt builtin may  be  used  to
       tailor  the  behavior  of  history  expansion.  If the hhiissttvveerriiffyy shell
       option is enabled (see the description of the sshhoopptt builtin below), and
       rreeaaddlliinnee  is  being  used,  history  substitutions  are not immediately
       passed to the shell parser.  Instead, the  expanded  line  is  reloaded
       into the rreeaaddlliinnee editing buffer for further modification.  If rreeaaddlliinnee
       is being used, and the hhiissttrreeeeddiitt shell option  is  enabled,  a  failed
       history  substitution will be reloaded into the rreeaaddlliinnee editing buffer
       for correction.  The --pp option to the hhiissttoorryy builtin  command  may  be
       used  to  see what a history expansion will do before using it.  The --ss
       option to the hhiissttoorryy builtin may be used to add commands to the end of
       the  history  list  without  actually  executing them, so that they are
       available for subsequent recall.

       The shell allows control of the various characters used by the  history
       expansion mechanism (see the description of hhiissttcchhaarrss above under SShheellll
       VVaarriiaabblleess).  The shell uses the history comment character to mark  his-
       tory timestamps when writing the history file.

   EEvveenntt DDeessiiggnnaattoorrss
       An  event designator is a reference to a command line entry in the his-
       tory list.

       !!      Start a history substitution, except when followed by  a  bbllaannkk,
              newline,  carriage return, = or ( (when the eexxttgglloobb shell option
              is enabled using the sshhoopptt builtin).
       !!_n     Refer to command line _n.
       !!--_n    Refer to the current command line minus _n.
       !!!!     Refer to the previous command.  This is a synonym for ‘!-1’.
       !!_s_t_r_i_n_g
              Refer to the most recent command starting with _s_t_r_i_n_g.
       !!??_s_t_r_i_n_g[[??]]
              Refer to the most recent command containing _s_t_r_i_n_g.  The  trail-
              ing ?? may be omitted if _s_t_r_i_n_g is followed immediately by a new-
              line.
       ^^_s_t_r_i_n_g_1^^_s_t_r_i_n_g_2^^
              Quick substitution.  Repeat the last command, replacing  _s_t_r_i_n_g_1
              with _s_t_r_i_n_g_2.  Equivalent to ‘‘!!:s/_s_t_r_i_n_g_1/_s_t_r_i_n_g_2/’’ (see MMoodd--
              iiffiieerrss below).
       !!##     The entire command line typed so far.

   WWoorrdd DDeessiiggnnaattoorrss
       Word designators are used to select desired words from the event.  A  ::
       separates  the event specification from the word designator.  It may be
       omitted if the word designator begins with a ^^, $$, **, --, or  %%.   Words
       are  numbered from the beginning of the line, with the first word being
       denoted by 0 (zero).  Words are inserted into the  current  line  sepa-
       rated by single spaces.

       00 ((zzeerroo))
              The zeroth word.  For the shell, this is the command word.
       _n      The _nth word.
       ^^      The first argument.  That is, word 1.
       $$      The last argument.
       %%      The word matched by the most recent ‘?_s_t_r_i_n_g?’ search.
       _x--_y    A range of words; ‘-_y’ abbreviates ‘0-_y’.
       **      All  of  the words but the zeroth.  This is a synonym for ‘_1_-_$’.
              It is not an error to use ** if there is just  one  word  in  the
              event; the empty string is returned in that case.
       xx**     Abbreviates _x_-_$.
       xx--     Abbreviates _x_-_$ like xx**, but omits the last word.

       If  a  word  designator is supplied without an event specification, the
       previous command is used as the event.

   MMooddiiffiieerrss
       After the optional word designator, there may appear a sequence of  one
       or more of the following modifiers, each preceded by a ‘:’.

       hh      Remove a trailing file name component, leaving only the head.
       tt      Remove all leading file name components, leaving the tail.
       rr      Remove a trailing suffix of the form _._x_x_x, leaving the basename.
       ee      Remove all but the trailing suffix.
       pp      Print the new command but do not execute it.
       qq      Quote the substituted words, escaping further substitutions.
       xx      Quote the substituted words as with qq, but break into  words  at
              bbllaannkkss and newlines.
       ss//_o_l_d//_n_e_w//
              Substitute  _n_e_w  for  the  first  occurrence of _o_l_d in the event
              line.  Any delimiter can be used  in  place  of  /.   The  final
              delimiter  is  optional if it is the last character of the event
              line.  The delimiter may be quoted in _o_l_d and _n_e_w with a  single
              backslash.   If & appears in _n_e_w, it is replaced by _o_l_d.  A sin-
              gle backslash will quote the &.  If _o_l_d is null, it  is  set  to
              the  last  _o_l_d substituted, or, if no previous history substitu-
              tions took place, the last _s_t_r_i_n_g in a !!??_s_t_r_i_n_g[[??]]  search.
       &&      Repeat the previous substitution.
       gg      Cause changes to be applied over the entire event line.  This is
              used  in  conjunction  with ‘::ss’ (e.g., ‘::ggss//_o_l_d//_n_e_w//’) or ‘::&&’.
              If used with ‘::ss’, any delimiter can be used in place of /,  and
              the  final  delimiter is optional if it is the last character of
              the event line.  An aa may be used as a synonym for gg.
       GG      Apply the following ‘ss’ modifier once to each word in the  event
              line.

SSHHEELLLL BBUUIILLTTIINN CCOOMMMMAANNDDSS
       Unless otherwise noted, each builtin command documented in this section
       as accepting options preceded by -- accepts ---- to signify the end of the
       options.   The  ::, ttrruuee, ffaallssee, and tteesstt builtins do not accept options
       and do not treat ---- specially.  The eexxiitt, llooggoouutt, bbrreeaakk, ccoonnttiinnuuee, lleett,
       and  sshhiifftt builtins accept and process arguments beginning with -- with-
       out requiring ----.  Other builtins that accept  arguments  but  are  not
       specified  as accepting options interpret arguments beginning with -- as
       invalid options and require ---- to prevent this interpretation.
       :: [_a_r_g_u_m_e_n_t_s]
              No effect; the command does nothing beyond  expanding  _a_r_g_u_m_e_n_t_s
              and  performing any specified redirections.  A zero exit code is
              returned.

        ..  _f_i_l_e_n_a_m_e [_a_r_g_u_m_e_n_t_s]
       ssoouurrccee _f_i_l_e_n_a_m_e [_a_r_g_u_m_e_n_t_s]
              Read and execute commands from _f_i_l_e_n_a_m_e  in  the  current  shell
              environment  and  return  the  exit  status  of the last command
              executed from _f_i_l_e_n_a_m_e.  If _f_i_l_e_n_a_m_e does not contain  a  slash,
              file  names  in  PPAATTHH  are used to find the directory containing
              _f_i_l_e_n_a_m_e.  The file searched for in PPAATTHH need not be executable.
              When  bbaasshh  is  not  in  _p_o_s_i_x  _m_o_d_e,  the  current directory is
              searched if no file is found in PPAATTHH.  If the ssoouurrcceeppaatthh  option
              to  the  sshhoopptt  builtin  command  is turned off, the PPAATTHH is not
              searched.  If any _a_r_g_u_m_e_n_t_s are supplied, they become the  posi-
              tional  parameters  when  _f_i_l_e_n_a_m_e  is  executed.  Otherwise the
              positional parameters are unchanged.  The return status  is  the
              status  of  the  last  command exited within the script (0 if no
              commands are executed), and false if _f_i_l_e_n_a_m_e is  not  found  or
              cannot be read.

       aalliiaass [--pp] [_n_a_m_e[=_v_a_l_u_e] ...]
              AAlliiaass with no arguments or with the --pp option prints the list of
              aliases in the form aalliiaass _n_a_m_e=_v_a_l_u_e on standard  output.   When
              arguments  are supplied, an alias is defined for each _n_a_m_e whose
              _v_a_l_u_e is given.  A trailing space in  _v_a_l_u_e causes the next word
              to be checked for alias substitution when the alias is expanded.
              For each _n_a_m_e in the argument list for which no  _v_a_l_u_e  is  sup-
              plied,  the  name  and  value  of  the  alias is printed.  AAlliiaass
              returns true unless a _n_a_m_e is given for which no alias has  been
              defined.

       bbgg [_j_o_b_s_p_e_c ...]
              Resume  each  suspended  job _j_o_b_s_p_e_c in the background, as if it
              had been started with &&.  If _j_o_b_s_p_e_c is not present, the shell’s
              notion  of the _c_u_r_r_e_n_t _j_o_b is used.  bbgg _j_o_b_s_p_e_c returns 0 unless
              run when job control is disabled or, when run with  job  control
              enabled,  any  specified  _j_o_b_s_p_e_c  was  not found or was started
              without job control.

       bbiinndd [--mm _k_e_y_m_a_p] [--llppssvvPPSSVV]
       bbiinndd [--mm _k_e_y_m_a_p] [--qq _f_u_n_c_t_i_o_n] [--uu _f_u_n_c_t_i_o_n] [--rr _k_e_y_s_e_q]
       bbiinndd [--mm _k_e_y_m_a_p] --ff _f_i_l_e_n_a_m_e
       bbiinndd [--mm _k_e_y_m_a_p] --xx _k_e_y_s_e_q:_s_h_e_l_l_-_c_o_m_m_a_n_d
       bbiinndd [--mm _k_e_y_m_a_p] _k_e_y_s_e_q:_f_u_n_c_t_i_o_n_-_n_a_m_e
       bbiinndd _r_e_a_d_l_i_n_e_-_c_o_m_m_a_n_d
              Display current rreeaaddlliinnee key and function bindings, bind  a  key
              sequence  to  a  rreeaaddlliinnee  function  or macro, or set a rreeaaddlliinnee
              variable.  Each non-option argument is a  command  as  it  would
              appear  in  _._i_n_p_u_t_r_c, but each binding or command must be passed
              as a separate argument; e.g.,  ’"\C-x\C-r":  re-read-init-file’.
              Options, if supplied, have the following meanings:
              --mm _k_e_y_m_a_p
                     Use _k_e_y_m_a_p as the keymap to be affected by the subsequent
                     bindings.  Acceptable _k_e_y_m_a_p names are _e_m_a_c_s_, _e_m_a_c_s_-_s_t_a_n_-
                     _d_a_r_d_,  _e_m_a_c_s_-_m_e_t_a_,  _e_m_a_c_s_-_c_t_l_x_,  _v_i_, _v_i_-_m_o_v_e_, _v_i_-_c_o_m_m_a_n_d,
                     and _v_i_-_i_n_s_e_r_t.  _v_i is equivalent to _v_i_-_c_o_m_m_a_n_d; _e_m_a_c_s  is
                     equivalent to _e_m_a_c_s_-_s_t_a_n_d_a_r_d.
              --ll     List the names of all rreeaaddlliinnee functions.
              --pp     Display  rreeaaddlliinnee  function  names and bindings in such a
                     way that they can be re-read.
              --PP     List current rreeaaddlliinnee function names and bindings.
              --ss     Display rreeaaddlliinnee key sequences bound to  macros  and  the
                     strings  they  output  in such a way that they can be re-
                     read.
              --SS     Display rreeaaddlliinnee key sequences bound to  macros  and  the
                     strings they output.
              --vv     Display  rreeaaddlliinnee variable names and values in such a way
                     that they can be re-read.
              --VV     List current rreeaaddlliinnee variable names and values.
              --ff _f_i_l_e_n_a_m_e
                     Read key bindings from _f_i_l_e_n_a_m_e.
              --qq _f_u_n_c_t_i_o_n
                     Query about which keys invoke the named _f_u_n_c_t_i_o_n.
              --uu _f_u_n_c_t_i_o_n
                     Unbind all keys bound to the named _f_u_n_c_t_i_o_n.
              --rr _k_e_y_s_e_q
                     Remove any current binding for _k_e_y_s_e_q.
              --xx _k_e_y_s_e_q::_s_h_e_l_l_-_c_o_m_m_a_n_d
                     Cause _s_h_e_l_l_-_c_o_m_m_a_n_d to be  executed  whenever  _k_e_y_s_e_q  is
                     entered.   When _s_h_e_l_l_-_c_o_m_m_a_n_d is executed, the shell sets
                     the RREEAADDLLIINNEE__LLIINNEE variable to the contents of  the  rreeaadd--
                     lliinnee  line  buffer and the RREEAADDLLIINNEE__PPOOIINNTT variable to the
                     current location of the insertion point.  If the executed
                     command  changes  the  value  of  RREEAADDLLIINNEE__LLIINNEE  or RREEAADD--
                     LLIINNEE__PPOOIINNTT, those new values will  be  reflected  in  the
                     editing state.

              The  return value is 0 unless an unrecognized option is given or
              an error occurred.

       bbrreeaakk [_n]
              Exit from within a ffoorr, wwhhiillee, uunnttiill, or sseelleecctt loop.  If  _n  is
              specified, break _n levels.  _n must be ≥ 1.  If _n is greater than
              the number of enclosing loops, all enclosing loops  are  exited.
              The  return  value  is  non-zero when _n is ≤ 0; Otherwise, bbrreeaakk
              returns 0 value.

       bbuuiillttiinn _s_h_e_l_l_-_b_u_i_l_t_i_n [_a_r_g_u_m_e_n_t_s]
              Execute the specified shell builtin, passing it  _a_r_g_u_m_e_n_t_s,  and
              return its exit status.  This is useful when defining a function
              whose name is the same as a shell builtin, retaining  the  func-
              tionality of the builtin within the function.  The ccdd builtin is
              commonly redefined this way.  The  return  status  is  false  if
              _s_h_e_l_l_-_b_u_i_l_t_i_n is not a shell builtin command.

       ccaalllleerr [_e_x_p_r]
              Returns the context of any active subroutine call (a shell func-
              tion or a script executed with the .. or ssoouurrccee builtins.   With-
              out _e_x_p_r, ccaalllleerr displays the line number and source filename of
              the current subroutine call.  If a non-negative integer is  sup-
              plied as _e_x_p_r, ccaalllleerr displays the line number, subroutine name,
              and source file corresponding to that position  in  the  current
              execution  call  stack.  This extra information may be used, for
              example, to print a stack trace.  The current frame is frame  0.
              The  return  value is 0 unless the shell is not executing a sub-
              routine call or _e_x_p_r does not correspond to a valid position  in
              the call stack.

       ccdd [--LL||--PP] [_d_i_r]
              Change  the  current directory to _d_i_r.  The variable HHOOMMEE is the
              default _d_i_r.  The variable CCDDPPAATTHH defines the  search  path  for
              the  directory  containing  _d_i_r.  Alternative directory names in
              CCDDPPAATTHH are separated by a colon (:).  A null directory  name  in
              CCDDPPAATTHH  is  the  same as the current directory, i.e., ‘‘..’’.  If
              _d_i_r begins with a slash (/), then CCDDPPAATTHH is  not  used.  The  --PP
              option  says  to use the physical directory structure instead of
              following symbolic links (see also the  --PP  option  to  the  sseett
              builtin command); the --LL option forces symbolic links to be fol-
              lowed.  An argument of -- is equivalent to $$OOLLDDPPWWDD.   If  a  non-
              empty  directory  name from CCDDPPAATTHH is used, or if -- is the first
              argument, and the directory change is successful,  the  absolute
              pathname of the new working directory is written to the standard
              output.  The return value is true if the directory was  success-
              fully changed; false otherwise.

       ccoommmmaanndd [--ppVVvv] _c_o_m_m_a_n_d [_a_r_g ...]
              Run  _c_o_m_m_a_n_d  with  _a_r_g_s  suppressing  the normal shell function
              lookup. Only builtin commands or commands found in the PPAATTHH  are
              executed.   If the --pp option is given, the search for _c_o_m_m_a_n_d is
              performed using a default value for PPAATTHH that is  guaranteed  to
              find  all  of  the  standard  utilities.  If either the --VV or --vv
              option is supplied, a description of _c_o_m_m_a_n_d is printed.  The --vv
              option  causes a single word indicating the command or file name
              used to invoke _c_o_m_m_a_n_d to be displayed; the --VV option produces a
              more  verbose  description.  If the --VV or --vv option is supplied,
              the exit status is 0 if _c_o_m_m_a_n_d was found, and  1  if  not.   If
              neither option is supplied and an error occurred or _c_o_m_m_a_n_d can-
              not be found, the exit status is 127.  Otherwise, the exit  sta-
              tus of the ccoommmmaanndd builtin is the exit status of _c_o_m_m_a_n_d.

       ccoommppggeenn [_o_p_t_i_o_n] [_w_o_r_d]
              Generate  possible  completion matches for _w_o_r_d according to the
              _o_p_t_i_o_ns, which may  be  any  option  accepted  by  the  ccoommpplleettee
              builtin  with  the exception of --pp and --rr, and write the matches
              to the standard output.  When using the --FF or  --CC  options,  the
              various  shell  variables  set  by  the  programmable completion
              facilities, while available, will not have useful values.

              The matches will be generated in the same way  as  if  the  pro-
              grammable  completion  code  had  generated them directly from a
              completion specification with the same flags.  If _w_o_r_d is speci-
              fied, only those completions matching _w_o_r_d will be displayed.

              The  return  value is true unless an invalid option is supplied,
              or no matches were generated.

       ccoommpplleettee [--aabbccddeeffggjjkkssuuvv] [--oo _c_o_m_p_-_o_p_t_i_o_n] [--DDEE] [--AA _a_c_t_i_o_n]  [--GG  _g_l_o_b_-
       _p_a_t] [--WW _w_o_r_d_l_i_s_t] [--FF _f_u_n_c_t_i_o_n] [--CC _c_o_m_m_a_n_d]
              [--XX _f_i_l_t_e_r_p_a_t] [--PP _p_r_e_f_i_x] [--SS _s_u_f_f_i_x] _n_a_m_e [_n_a_m_e _._._.]
       ccoommpplleettee --pprr [--DDEE] [_n_a_m_e ...]
              Specify how arguments to each _n_a_m_e should be completed.  If  the
              --pp  option  is supplied, or if no options are supplied, existing
              completion specifications are printed in a way that allows  them
              to be reused as input.  The --rr option removes a completion spec-
              ification for each _n_a_m_e, or, if no _n_a_m_es are supplied, all  com-
              pletion  specifications.   The  --DD  option  indicates  that  the
              remaining options and actions should apply  to  the  ‘‘default’’
              command  completion;  that is, completion attempted on a command
              for which no completion has previously  been  defined.   The  --EE
              option  indicates  that the remaining options and actions should
              apply to  ‘‘empty’’  command  completion;  that  is,  completion
              attempted on a blank line.

              The  process  of  applying  these completion specifications when
              word completion is  attempted  is  described  above  under  PPrroo--
              ggrraammmmaabbllee CCoommpplleettiioonn.

              Other  options,  if specified, have the following meanings.  The
              arguments to the --GG, --WW, and --XX options (and, if necessary,  the
              --PP  and --SS options) should be quoted to protect them from expan-
              sion before the ccoommpplleettee builtin is invoked.
              --oo _c_o_m_p_-_o_p_t_i_o_n
                      The _c_o_m_p_-_o_p_t_i_o_n controls several aspects  of  the  comp-
                      spec’s  behavior beyond the simple generation of comple-
                      tions.  _c_o_m_p_-_o_p_t_i_o_n may be one of:
                      bbaasshhddeeffaauulltt
                              Perform the rest of the default bbaasshh completions
                              if the compspec generates no matches.
                      ddeeffaauulltt Use  readline’s  default  filename completion if
                              the compspec generates no matches.
                      ddiirrnnaammeess
                              Perform directory name completion if  the  comp-
                              spec generates no matches.
                      ffiilleennaammeess
                              Tell  readline that the compspec generates file-
                              names, so it can perform  any  filename-specific
                              processing  (like  adding  a  slash to directory
                              names, quoting special characters, or  suppress-
                              ing  trailing spaces).  Intended to be used with
                              shell functions.
                      nnoossppaaccee Tell  readline  not  to  append  a  space   (the
                              default)  to  words  completed at the end of the
                              line.
                      pplluussddiirrss
                              After any matches defined by  the  compspec  are
                              generated,    directory   name   completion   is
                              attempted and  any  matches  are  added  to  the
                              results of the other actions.
              --AA _a_c_t_i_o_n
                      The  _a_c_t_i_o_n  may  be  one of the following to generate a
                      list of possible completions:
                      aalliiaass   Alias names.  May also be specified as --aa.
                      aarrrraayyvvaarr
                              Array variable names.
                      bbiinnddiinngg RReeaaddlliinnee key binding names.
                      bbuuiillttiinn Names of shell builtin commands.   May  also  be
                              specified as --bb.
                      ccoommmmaanndd Command names.  May also be specified as --cc.
                      ddiirreeccttoorryy
                              Directory names.  May also be specified as --dd.
                      ddiissaabblleedd
                              Names of disabled shell builtins.
                      eennaabblleedd Names of enabled shell builtins.
                      eexxppoorrtt  Names  of exported shell variables.  May also be
                              specified as --ee.
                      ffiillee    File names.  May also be specified as --ff.
                      ffuunnccttiioonn
                              Names of shell functions.
                      ggrroouupp   Group names.  May also be specified as --gg.
                      hheellppttooppiicc
                              Help topics as accepted by the hheellpp builtin.
                      hhoossttnnaammee
                              Hostnames, as taken from the file  specified  by
                              the HHOOSSTTFFIILLEE shell variable.
                      jjoobb     Job  names,  if job control is active.  May also
                              be specified as --jj.
                      kkeeyywwoorrdd Shell reserved words.  May also be specified  as
                              --kk.
                      rruunnnniinngg Names of running jobs, if job control is active.
                      sseerrvviiccee Service names.  May also be specified as --ss.
                      sseettoopptt  Valid arguments for the --oo  option  to  the  sseett
                              builtin.
                      sshhoopptt   Shell  option  names  as  accepted  by the sshhoopptt
                              builtin.
                      ssiiggnnaall  Signal names.
                      ssttooppppeedd Names of stopped jobs, if job control is active.
                      uusseerr    User names.  May also be specified as --uu.
                      vvaarriiaabbllee
                              Names of all shell variables.  May also be spec-
                              ified as --vv.
              --GG _g_l_o_b_p_a_t
                      The pathname expansion pattern _g_l_o_b_p_a_t  is  expanded  to
                      generate the possible completions.
              --WW _w_o_r_d_l_i_s_t
                      The  _w_o_r_d_l_i_s_t  is  split using the characters in the IIFFSS
                      special variable as delimiters, and each resultant  word
                      is  expanded.   The possible completions are the members
                      of the resultant list which match the  word  being  com-
                      pleted.
              --CC _c_o_m_m_a_n_d
                      _c_o_m_m_a_n_d  is  executed in a subshell environment, and its
                      output is used as the possible completions.
              --FF _f_u_n_c_t_i_o_n
                      The shell function _f_u_n_c_t_i_o_n is executed in  the  current
                      shell  environment.  When it finishes, the possible com-
                      pletions are retrieved from the value of  the  CCOOMMPPRREEPPLLYY
                      array variable.
              --XX _f_i_l_t_e_r_p_a_t
                      _f_i_l_t_e_r_p_a_t  is  a pattern as used for pathname expansion.
                      It is applied to the list of possible completions gener-
                      ated  by  the  preceding options and arguments, and each
                      completion matching _f_i_l_t_e_r_p_a_t is removed from the  list.
                      A  leading  !!  in _f_i_l_t_e_r_p_a_t negates the pattern; in this
                      case, any completion not matching _f_i_l_t_e_r_p_a_t is  removed.
              --PP _p_r_e_f_i_x
                      _p_r_e_f_i_x  is  added at the beginning of each possible com-
                      pletion after all other options have been applied.
              --SS _s_u_f_f_i_x
                      _s_u_f_f_i_x is appended to each possible completion after all
                      other options have been applied.

              The  return  value is true unless an invalid option is supplied,
              an option other than --pp or --rr is supplied without a  _n_a_m_e  argu-
              ment,  an  attempt  is made to remove a completion specification
              for a _n_a_m_e for which no specification exists, or an error occurs
              adding a completion specification.

       ccoommppoopptt [--oo _o_p_t_i_o_n] [--DDEE] [++oo _o_p_t_i_o_n] [_n_a_m_e]
              Modify  completion  options  for  each  _n_a_m_e  according  to  the
              _o_p_t_i_o_ns, or for the currently-execution completion if  no  _n_a_m_es
              are  supplied.   If no _o_p_t_i_o_ns are given, display the completion
              options for each _n_a_m_e or the current completion.   The  possible
              values  of  _o_p_t_i_o_n  are  those  valid  for  the ccoommpplleettee builtin
              described above.  The --DD option  indicates  that  the  remaining
              options should apply to the ‘‘default’’ command completion; that
              is, completion attempted on a command for  which  no  completion
              has  previously  been defined.  The --EE option indicates that the
              remaining options should apply to ‘‘empty’’ command  completion;
              that is, completion attempted on a blank line.

       The  return  value  is  true  unless  an invalid option is supplied, an
       attempt is made to modify the options for a _n_a_m_e for which  no  comple-
       tion specification exists, or an output error occurs.

       ccoonnttiinnuuee [_n]
              Resume the next iteration of the enclosing ffoorr, wwhhiillee, uunnttiill, or
              sseelleecctt loop.  If _n is specified, resume  at  the  _nth  enclosing
              loop.   _n  must  be  ≥  1.   If  _n is greater than the number of
              enclosing loops, the  last  enclosing  loop  (the  ‘‘top-level’’
              loop) is resumed.  When ccoonnttiinnuuee is executed inside of loop, the
              return value is non-zero when _n  is  ≤  0;  Otherwise,  ccoonnttiinnuuee
              returns  0 value. When ccoonnttiinnuuee is executed outside of loop, the
              return value is 0.

       ddeeccllaarree [--aaAAffFFiillrrttuuxx] [--pp] [_n_a_m_e[=_v_a_l_u_e] ...]
       ttyyppeesseett [--aaAAffFFiillrrttuuxx] [--pp] [_n_a_m_e[=_v_a_l_u_e] ...]
              Declare variables and/or give them attributes.  If no _n_a_m_es  are
              given  then display the values of variables.  The --pp option will
              display the attributes and values of each _n_a_m_e.  When --pp is used
              with _n_a_m_e arguments, additional options are ignored.  When --pp is
              supplied without _n_a_m_e arguments, it will display the  attributes
              and  values  of all variables having the attributes specified by
              the additional options.  If no other options are  supplied  with
              --pp,  ddeeccllaarree will display the attributes and values of all shell
              variables.  The --ff option will restrict  the  display  to  shell
              functions.  The --FF option inhibits the display of function defi-
              nitions; only the function name and attributes are printed.   If
              the  eexxttddeebbuugg  shell  option  is enabled using sshhoopptt, the source
              file name and line number where the function is defined are dis-
              played  as  well.   The  --FF  option  implies  --ff.  The following
              options can be used to restrict output  to  variables  with  the
              specified attribute or to give variables attributes:
              --aa     Each  _n_a_m_e  is  an  indexed  array  variable  (see AArrrraayyss
                     above).
              --AA     Each _n_a_m_e is an associative array  variable  (see  AArrrraayyss
                     above).
              --ff     Use function names only.
              --ii     The variable is treated as an integer; arithmetic evalua-
                     tion (see AARRIITTHHMMEETTIICC EEVVAALLUUAATTIIOONN above) is performed  when
                     the variable is assigned a value.
              --ll     When  the  variable  is  assigned a value, all upper-case
                     characters are converted to lower-case.   The  upper-case
                     attribute is disabled.
              --rr     Make _n_a_m_es readonly.  These names cannot then be assigned
                     values by subsequent assignment statements or unset.
              --tt     Give each _n_a_m_e the  _t_r_a_c_e  attribute.   Traced  functions
                     inherit  the  DDEEBBUUGG  and  RREETTUURRNN  traps  from the calling
                     shell.  The trace attribute has no  special  meaning  for
                     variables.
              --uu     When  the  variable  is  assigned a value, all lower-case
                     characters are converted to upper-case.   The  lower-case
                     attribute is disabled.
              --xx     Mark  _n_a_m_es  for  export  to  subsequent commands via the
                     environment.

              Using ‘+’ instead of ‘-’ turns off the attribute  instead,  with
              the exceptions that ++aa may not be used to destroy an array vari-
              able and ++rr will not remove the readonly attribute.   When  used
              in a function, makes each _n_a_m_e local, as with the llooccaall command.
              If a variable name is followed by =_v_a_l_u_e, the value of the vari-
              able  is  set to _v_a_l_u_e.  The return value is 0 unless an invalid
              option is encountered, an attempt is made to define  a  function
              using  ‘‘-f foo=bar’’, an attempt is made to assign a value to a
              readonly variable, an attempt is made to assign a  value  to  an
              array variable without using the compound assignment syntax (see
              AArrrraayyss above), one of the _n_a_m_e_s is not a  valid  shell  variable
              name, an attempt is made to turn off readonly status for a read-
              only variable, an attempt is made to turn off array  status  for
              an  array variable, or an attempt is made to display a non-exis-
              tent function with --ff.

       ddiirrss [[++_n]] [[--_n]] [[--ccppllvv]]
              Without options,  displays  the  list  of  currently  remembered
              directories.   The  default  display  is  on  a single line with
              directory names separated by spaces.  Directories are  added  to
              the  list  with  the  ppuusshhdd  command;  the  ppooppdd command removes
              entries from the list.
              ++_n     Displays the _nth entry counting from the left of the list
                     shown by ddiirrss when invoked without options, starting with
                     zero.
              --_n     Displays the _nth entry counting from  the  right  of  the
                     list shown by ddiirrss when invoked without options, starting
                     with zero.
              --cc     Clears  the  directory  stack  by  deleting  all  of  the
                     entries.
              --ll     Produces  a  longer  listing;  the default listing format
                     uses a tilde to denote the home directory.
              --pp     Print the directory stack with one entry per line.
              --vv     Print the directory stack with one entry per  line,  pre-
                     fixing each entry with its index in the stack.

              The  return value is 0 unless an invalid option is supplied or _n
              indexes beyond the end of the directory stack.

       ddiissoowwnn [--aarr] [--hh] [_j_o_b_s_p_e_c ...]
              Without options, each _j_o_b_s_p_e_c  is  removed  from  the  table  of
              active  jobs.   If _j_o_b_s_p_e_c is not present, and neither --aa nor --rr
              is supplied, the shell’s notion of the _c_u_r_r_e_n_t _j_o_b is used.   If
              the --hh option is given, each _j_o_b_s_p_e_c is not removed from the ta-
              ble, but is marked so that SSIIGGHHUUPP is not sent to the job if  the
              shell  receives a SSIIGGHHUUPP.  If no _j_o_b_s_p_e_c is present, and neither
              the --aa nor the --rr option is supplied, the _c_u_r_r_e_n_t _j_o_b  is  used.
              If no _j_o_b_s_p_e_c is supplied, the --aa option means to remove or mark
              all jobs; the --rr option without  a  _j_o_b_s_p_e_c  argument  restricts
              operation  to running jobs.  The return value is 0 unless a _j_o_b_-
              _s_p_e_c does not specify a valid job.

       eecchhoo [--nneeEE] [_a_r_g ...]
              Output the _a_r_gs, separated by spaces,  followed  by  a  newline.
              The return status is always 0.  If --nn is specified, the trailing
              newline is suppressed.  If the --ee option is  given,  interpreta-
              tion  of  the following backslash-escaped characters is enabled.
              The --EE option disables the interpretation of these escape  char-
              acters,  even  on systems where they are interpreted by default.
              The xxppgg__eecchhoo shell option may be used to  dynamically  determine
              whether  or not eecchhoo expands these escape characters by default.
              eecchhoo does not interpret ---- to mean the  end  of  options.   eecchhoo
              interprets the following escape sequences:
              \\aa     alert (bell)
              \\bb     backspace
              \\cc     suppress further output
              \\ee     an escape character
              \\ff     form feed
              \\nn     new line
              \\rr     carriage return
              \\tt     horizontal tab
              \\vv     vertical tab
              \\\\     backslash
              \\00_n_n_n  the  eight-bit  character  whose value is the octal value
                     _n_n_n (zero to three octal digits)
              \\xx_H_H   the eight-bit character whose value  is  the  hexadecimal
                     value _H_H (one or two hex digits)

       eennaabbllee [--aa] [--ddnnppss] [--ff _f_i_l_e_n_a_m_e] [_n_a_m_e ...]
              Enable  and disable builtin shell commands.  Disabling a builtin
              allows a disk command which has the same name as a shell builtin
              to  be  executed without specifying a full pathname, even though
              the shell normally searches for builtins before  disk  commands.
              If  --nn  is  used,  each  _n_a_m_e  is disabled; otherwise, _n_a_m_e_s are
              enabled.  For example, to use the tteesstt binary found via the PPAATTHH
              instead  of  the  shell builtin version, run ‘‘enable -n test’’.
              The --ff option means to load the new builtin  command  _n_a_m_e  from
              shared object _f_i_l_e_n_a_m_e, on systems that support dynamic loading.
              The --dd option will delete a builtin previously loaded  with  --ff.
              If no _n_a_m_e arguments are given, or if the --pp option is supplied,
              a list of shell builtins is printed.  With no other option argu-
              ments,  the  list consists of all enabled shell builtins.  If --nn
              is supplied, only disabled builtins are printed.  If --aa is  sup-
              plied,  the  list printed includes all builtins, with an indica-
              tion of whether or not each is enabled.  If --ss is supplied,  the
              output  is restricted to the POSIX _s_p_e_c_i_a_l builtins.  The return
              value is 0 unless a _n_a_m_e is not a shell builtin or there  is  an
              error loading a new builtin from a shared object.

       eevvaall [_a_r_g ...]
              The  _a_r_gs  are read and concatenated together into a single com-
              mand.  This command is then read and executed by the shell,  and
              its  exit status is returned as the value of eevvaall.  If there are
              no _a_r_g_s, or only null arguments, eevvaall returns 0.

       eexxeecc [--ccll] [--aa _n_a_m_e] [_c_o_m_m_a_n_d [_a_r_g_u_m_e_n_t_s]]
              If _c_o_m_m_a_n_d is specified, it replaces the shell.  No new  process
              is  created.  The _a_r_g_u_m_e_n_t_s become the arguments to _c_o_m_m_a_n_d.  If
              the --ll option is supplied, the shell places a dash at the begin-
              ning  of  the  zeroth  argument passed to _c_o_m_m_a_n_d.  This is what
              _l_o_g_i_n(1) does.  The --cc option causes _c_o_m_m_a_n_d to be executed with
              an  empty environment.  If --aa is supplied, the shell passes _n_a_m_e
              as the zeroth argument to the executed command.  If _c_o_m_m_a_n_d can-
              not  be executed for some reason, a non-interactive shell exits,
              unless the shell option eexxeeccffaaiill is enabled, in  which  case  it
              returns  failure.   An  interactive shell returns failure if the
              file cannot be executed.  If _c_o_m_m_a_n_d is not specified, any redi-
              rections take effect in the current shell, and the return status
              is 0.  If there is a redirection error, the return status is  1.

       eexxiitt [_n]
              Cause  the  shell  to exit with a status of _n.  If _n is omitted,
              the exit status is that of the last command executed.  A trap on
              EEXXIITT is executed before the shell terminates.

       eexxppoorrtt [--ffnn] [_n_a_m_e[=_w_o_r_d]] ...
       eexxppoorrtt --pp
              The  supplied _n_a_m_e_s are marked for automatic export to the envi-
              ronment of subsequently executed commands.  If the --ff option  is
              given,  the _n_a_m_e_s refer to functions.  If no _n_a_m_e_s are given, or
              if the --pp option is supplied, a  list  of  all  names  that  are
              exported  in  this  shell  is printed.  The --nn option causes the
              export property to be removed from each  _n_a_m_e.   If  a  variable
              name  is  followed by =_w_o_r_d, the value of the variable is set to
              _w_o_r_d.  eexxppoorrtt returns an exit status  of  0  unless  an  invalid
              option  is  encountered,  one  of the _n_a_m_e_s is not a valid shell
              variable name, or --ff is supplied with a _n_a_m_e that is not a func-
              tion.

       ffcc [--ee _e_n_a_m_e] [--llnnrr] [_f_i_r_s_t] [_l_a_s_t]
       ffcc --ss [_p_a_t=_r_e_p] [_c_m_d]
              Fix  Command.  In the first form, a range of commands from _f_i_r_s_t
              to _l_a_s_t is selected from the history list.  _F_i_r_s_t and  _l_a_s_t  may
              be  specified  as a string (to locate the last command beginning
              with that string) or as a number  (an  index  into  the  history
              list, where a negative number is used as an offset from the cur-
              rent command number).  If _l_a_s_t is not specified it is set to the
              current  command  for  listing (so that ‘‘fc -l -10’’ prints the
              last 10 commands) and to _f_i_r_s_t otherwise.  If _f_i_r_s_t is not spec-
              ified  it is set to the previous command for editing and -16 for
              listing.

              The --nn option suppresses the command numbers when listing.   The
              --rr  option reverses the order of the commands.  If the --ll option
              is given, the commands are listed on  standard  output.   Other-
              wise,  the editor given by _e_n_a_m_e is invoked on a file containing
              those commands.  If _e_n_a_m_e is not given, the value of the  FFCCEEDDIITT
              variable  is used, and the value of EEDDIITTOORR if FFCCEEDDIITT is not set.
              If neither variable is set, _v_i is used.  When  editing  is  com-
              plete, the edited commands are echoed and executed.

              In  the  second form, _c_o_m_m_a_n_d is re-executed after each instance
              of _p_a_t is replaced by _r_e_p.  A useful alias to use with  this  is
              ‘‘r="fc  -s"’’,  so  that  typing ‘‘r cc’’ runs the last command
              beginning with ‘‘cc’’ and typing ‘‘r’’ re-executes the last com-
              mand.

              If  the  first  form  is  used,  the return value is 0 unless an
              invalid option is encountered or _f_i_r_s_t or _l_a_s_t  specify  history
              lines  out  of  range.  If the --ee option is supplied, the return
              value is the value of the last command executed or failure if an
              error occurs with the temporary file of commands.  If the second
              form is used, the return status is that of the  command  re-exe-
              cuted,  unless  _c_m_d  does  not  specify a valid history line, in
              which case ffcc returns failure.

       ffgg [_j_o_b_s_p_e_c]
              Resume _j_o_b_s_p_e_c in the foreground, and make it the  current  job.
              If _j_o_b_s_p_e_c is not present, the shell’s notion of the _c_u_r_r_e_n_t _j_o_b
              is used.  The return value is that of the  command  placed  into
              the  foreground,  or failure if run when job control is disabled
              or, when run with job control enabled, if _j_o_b_s_p_e_c does not spec-
              ify  a  valid  job  or  _j_o_b_s_p_e_c specifies a job that was started
              without job control.

       ggeettooppttss _o_p_t_s_t_r_i_n_g _n_a_m_e [_a_r_g_s]
              ggeettooppttss is used by shell procedures to parse positional  parame-
              ters.   _o_p_t_s_t_r_i_n_g  contains  the  option characters to be recog-
              nized; if a character is followed by  a  colon,  the  option  is
              expected  to have an argument, which should be separated from it
              by white space.  The colon and question mark characters may  not
              be  used as option characters.  Each time it is invoked, ggeettooppttss
              places the next option in the shell variable _n_a_m_e,  initializing
              _n_a_m_e if it does not exist, and the index of the next argument to
              be processed into the variable OOPPTTIINNDD.  OOPPTTIINNDD is initialized to
              1  each  time  the  shell or a shell script is invoked.  When an
              option requires an argument, ggeettooppttss places that  argument  into
              the  variable OOPPTTAARRGG.  The shell does not reset OOPPTTIINNDD automati-
              cally; it must be  manually  reset  between  multiple  calls  to
              ggeettooppttss within the same shell invocation if a new set of parame-
              ters is to be used.

              When the end of options is encountered,  ggeettooppttss  exits  with  a
              return  value  greater than zero.  OOPPTTIINNDD is set to the index of
              the first non-option argument, and nnaammee is set to ?.

              ggeettooppttss normally parses the positional parameters, but  if  more
              arguments are given in _a_r_g_s, ggeettooppttss parses those instead.

              ggeettooppttss  can  report errors in two ways.  If the first character
              of _o_p_t_s_t_r_i_n_g is a colon, _s_i_l_e_n_t error  reporting  is  used.   In
              normal  operation  diagnostic  messages are printed when invalid
              options or missing option arguments  are  encountered.   If  the
              variable  OOPPTTEERRRR  is  set  to  0, no error messages will be dis-
              played, even if the first character of _o_p_t_s_t_r_i_n_g is not a colon.

              If an invalid option is seen, ggeettooppttss places ? into _n_a_m_e and, if
              not silent, prints an  error  message  and  unsets  OOPPTTAARRGG.   If
              ggeettooppttss  is  silent,  the  option  character  found is placed in
              OOPPTTAARRGG and no diagnostic message is printed.

              If a required argument is not found, and ggeettooppttss is not  silent,
              a  question  mark  (??) is placed in _n_a_m_e, OOPPTTAARRGG is unset, and a
              diagnostic message is printed.  If ggeettooppttss  is  silent,  then  a
              colon  (::)  is  placed  in  _n_a_m_e and OOPPTTAARRGG is set to the option
              character found.

              ggeettooppttss returns true if an option, specified or unspecified,  is
              found.  It returns false if the end of options is encountered or
              an error occurs.

       hhaasshh [--llrr] [--pp _f_i_l_e_n_a_m_e] [--ddtt] [_n_a_m_e]
              For each _n_a_m_e, the full file name of the command  is  determined
              by searching the directories in $$PPAATTHH and remembered.  If the --pp
              option is supplied, no path search is performed, and _f_i_l_e_n_a_m_e is
              used as the full file name of the command.  The --rr option causes
              the shell to forget all remembered  locations.   The  --dd  option
              causes the shell to forget the remembered location of each _n_a_m_e.
              If the --tt option is supplied, the full pathname  to  which  each
              _n_a_m_e  corresponds  is  printed.   If multiple _n_a_m_e arguments are
              supplied with --tt, the _n_a_m_e is printed  before  the  hashed  full
              pathname.  The --ll option causes output to be displayed in a for-
              mat that may be reused as input.  If no arguments are given,  or
              if only --ll is supplied, information about remembered commands is
              printed.  The return status is true unless a _n_a_m_e is  not  found
              or an invalid option is supplied.

       hheellpp [--ddmmss] [_p_a_t_t_e_r_n]
              Display  helpful information about builtin commands.  If _p_a_t_t_e_r_n
              is specified, hheellpp gives detailed help on all commands  matching
              _p_a_t_t_e_r_n;  otherwise  help for all the builtins and shell control
              structures is printed.
              --dd     Display a short description of each _p_a_t_t_e_r_n
              --mm     Display the description of each _p_a_t_t_e_r_n in a manpage-like
                     format
              --ss     Display only a short usage synopsis for each _p_a_t_t_e_r_n
       The return status is 0 unless no command matches _p_a_t_t_e_r_n.

       hhiissttoorryy [[_n]]
       hhiissttoorryy --cc
       hhiissttoorryy --dd _o_f_f_s_e_t
       hhiissttoorryy --aannrrww [_f_i_l_e_n_a_m_e]
       hhiissttoorryy --pp _a_r_g [_a_r_g _._._.]
       hhiissttoorryy --ss _a_r_g [_a_r_g _._._.]
              With no options, display the command history list with line num-
              bers.  Lines listed with a ** have been modified.  An argument of
              _n  lists only the last _n lines.  If the shell variable HHIISSTTTTIIMMEE--
              FFOORRMMAATT is set and not null, it is used as a  format  string  for
              _s_t_r_f_t_i_m_e(3)  to display the time stamp associated with each dis-
              played history entry.  No intervening blank is  printed  between
              the  formatted  time stamp and the history line.  If _f_i_l_e_n_a_m_e is
              supplied, it is used as the name of the history  file;  if  not,
              the  value  of HHIISSTTFFIILLEE is used.  Options, if supplied, have the
              following meanings:
              --cc     Clear the history list by deleting all the entries.
              --dd _o_f_f_s_e_t
                     Delete the history entry at position _o_f_f_s_e_t.
              --aa     Append the ‘‘new’’ history lines (history  lines  entered
                     since  the  beginning of the current bbaasshh session) to the
                     history file.
              --nn     Read the history lines not already read from the  history
                     file  into  the  current  history  list.  These are lines
                     appended to the history file since the beginning  of  the
                     current bbaasshh session.
              --rr     Read the contents of the history file and use them as the
                     current history.
              --ww     Write the current history to the history file,  overwrit-
                     ing the history file’s contents.
              --pp     Perform  history  substitution  on the following _a_r_g_s and
                     display the result on  the  standard  output.   Does  not
                     store  the results in the history list.  Each _a_r_g must be
                     quoted to disable normal history expansion.
              --ss     Store the _a_r_g_s in the history list  as  a  single  entry.
                     The  last  command  in the history list is removed before
                     the _a_r_g_s are added.

              If the HHIISSTTTTIIMMEEFFOORRMMAATT variable is set, the time  stamp  informa-
              tion  associated  with each history entry is written to the his-
              tory file, marked with the history comment character.  When  the
              history  file  is read, lines beginning with the history comment
              character followed immediately by a  digit  are  interpreted  as
              timestamps for the previous history line.  The return value is 0
              unless an invalid option is encountered, an error  occurs  while
              reading  or  writing the history file, an invalid _o_f_f_s_e_t is sup-
              plied as an argument to --dd, or the history expansion supplied as
              an argument to --pp fails.

       jjoobbss [--llnnpprrss] [ _j_o_b_s_p_e_c ... ]
       jjoobbss --xx _c_o_m_m_a_n_d [ _a_r_g_s ... ]
              The first form lists the active jobs.  The options have the fol-
              lowing meanings:
              --ll     List process IDs in addition to the normal information.
              --pp     List only the process  ID  of  the  job’s  process  group
                     leader.
              --nn     Display  information  only  about  jobs that have changed
                     status since the user was last notified of their  status.
              --rr     Restrict output to running jobs.
              --ss     Restrict output to stopped jobs.

              If  _j_o_b_s_p_e_c  is given, output is restricted to information about
              that job.  The return status is 0 unless an  invalid  option  is
              encountered or an invalid _j_o_b_s_p_e_c is supplied.

              If the --xx option is supplied, jjoobbss replaces any _j_o_b_s_p_e_c found in
              _c_o_m_m_a_n_d or _a_r_g_s with the corresponding  process  group  ID,  and
              executes _c_o_m_m_a_n_d passing it _a_r_g_s, returning its exit status.

       kkiillll [--ss _s_i_g_s_p_e_c | --nn _s_i_g_n_u_m | --_s_i_g_s_p_e_c] [_p_i_d | _j_o_b_s_p_e_c] ...
       kkiillll --ll [_s_i_g_s_p_e_c | _e_x_i_t___s_t_a_t_u_s]
              Send  the  signal  named  by  _s_i_g_s_p_e_c or _s_i_g_n_u_m to the processes
              named by _p_i_d or _j_o_b_s_p_e_c.  _s_i_g_s_p_e_c is either  a  case-insensitive
              signal  name such as SSIIGGKKIILLLL (with or without the SSIIGG prefix) or
              a signal number; _s_i_g_n_u_m is a signal number.  If _s_i_g_s_p_e_c  is  not
              present,  then  SSIIGGTTEERRMM is assumed.  An argument of --ll lists the
              signal names.  If any arguments are supplied when --ll  is  given,
              the  names  of  the  signals  corresponding to the arguments are
              listed, and the return status is 0.  The _e_x_i_t___s_t_a_t_u_s argument to
              --ll  is  a  number  specifying either a signal number or the exit
              status of a process terminated by a signal.  kkiillll  returns  true
              if  at  least  one  signal was successfully sent, or false if an
              error occurs or an invalid option is encountered.

       lleett _a_r_g [_a_r_g ...]
              Each _a_r_g is an arithmetic expression to be evaluated (see AARRIITTHH--
              MMEETTIICC  EEVVAALLUUAATTIIOONN  above).   If the last _a_r_g evaluates to 0, lleett
              returns 1; 0 is returned otherwise.

       llooccaall [_o_p_t_i_o_n] [_n_a_m_e[=_v_a_l_u_e] ...]
              For each argument, a local variable named _n_a_m_e is  created,  and
              assigned  _v_a_l_u_e.   The _o_p_t_i_o_n can be any of the options accepted
              by ddeeccllaarree.  When llooccaall is used within a function, it causes the
              variable  _n_a_m_e  to have a visible scope restricted to that func-
              tion and its children.  With no operands, llooccaall writes a list of
              local  variables  to the standard output.  It is an error to use
              llooccaall when not within a function.  The return status is 0 unless
              llooccaall  is  used outside a function, an invalid _n_a_m_e is supplied,
              or _n_a_m_e is a readonly variable.

       llooggoouutt Exit a login shell.

       mmaappffiillee [--nn _c_o_u_n_t] [--OO _o_r_i_g_i_n] [--ss _c_o_u_n_t] [--tt] [--uu  _f_d]  [--CC  _c_a_l_l_b_a_c_k]
       [--cc _q_u_a_n_t_u_m] [_a_r_r_a_y]
       rreeaaddaarrrraayy [--nn _c_o_u_n_t] [--OO _o_r_i_g_i_n] [--ss _c_o_u_n_t] [--tt] [--uu _f_d] [--CC  _c_a_l_l_b_a_c_k]
       [--cc _q_u_a_n_t_u_m] [_a_r_r_a_y]
              Read lines from the standard input into the indexed array  vari-
              able  _a_r_r_a_y, or from file descriptor _f_d if the --uu option is sup-
              plied.  The variable MMAAPPFFIILLEE is the default _a_r_r_a_y.  Options,  if
              supplied, have the following meanings:
              --nn     Copy  at  most _c_o_u_n_t lines.  If _c_o_u_n_t is 0, all lines are
                     copied.
              --OO     Begin assigning to _a_r_r_a_y at index  _o_r_i_g_i_n.   The  default
                     index is 0.
              --ss     Discard the first _c_o_u_n_t lines read.
              --tt     Remove a trailing newline from each line read.
              --uu     Read  lines  from file descriptor _f_d instead of the stan-
                     dard input.
              --CC     Evaluate _c_a_l_l_b_a_c_k each time _q_u_a_n_t_u_m lines are read.   The
                     --cc option specifies _q_u_a_n_t_u_m.
              --cc     Specify  the  number  of  lines read between each call to
                     _c_a_l_l_b_a_c_k.

              If --CC is specified without --cc,  the  default  quantum  is  5000.
              When _c_a_l_l_b_a_c_k is evaluated, it is supplied the index of the next
              array element to be assigned as an additional  argument.   _c_a_l_l_-
              _b_a_c_k  is  evaluated  after the line is read but before the array
              element is assigned.

              If not supplied with an  explicit  origin,  mmaappffiillee  will  clear
              _a_r_r_a_y before assigning to it.

              mmaappffiillee  returns successfully unless an invalid option or option
              argument is supplied, _a_r_r_a_y is invalid or  unassignable,  or  if
              _a_r_r_a_y is not an indexed array.

       ppooppdd [-nn] [+_n] [-_n]
              Removes  entries  from  the directory stack.  With no arguments,
              removes the top directory from the stack, and performs a  ccdd  to
              the new top directory.  Arguments, if supplied, have the follow-
              ing meanings:
              --nn     Suppresses the normal change of directory  when  removing
                     directories  from  the  stack,  so that only the stack is
                     manipulated.
              ++_n     Removes the _nth entry counting from the left of the  list
                     shown  by  ddiirrss, starting with zero.  For example: ‘‘popd
                     +0’’ removes the first directory, ‘‘popd +1’’ the second.
              --_n     Removes the _nth entry counting from the right of the list
                     shown by ddiirrss, starting with zero.  For  example:  ‘‘popd
                     -0’’  removes the last directory, ‘‘popd -1’’ the next to
                     last.

              If the ppooppdd command is successful, a ddiirrss is performed as  well,
              and  the  return  status is 0.  ppooppdd returns false if an invalid
              option is encountered, the directory stack is empty, a non-exis-
              tent directory stack entry is specified, or the directory change
              fails.

       pprriinnttff [--vv _v_a_r] _f_o_r_m_a_t [_a_r_g_u_m_e_n_t_s]
              Write the formatted _a_r_g_u_m_e_n_t_s to the standard output  under  the
              control  of  the _f_o_r_m_a_t.  The _f_o_r_m_a_t is a character string which
              contains three types of objects:  plain  characters,  which  are
              simply  copied  to  standard output, character escape sequences,
              which are converted and copied to the standard output, and  for-
              mat  specifications,  each  of which causes printing of the next
              successive _a_r_g_u_m_e_n_t.  In addition to the standard _p_r_i_n_t_f(1) for-
              mats,  %%bb  causes pprriinnttff to expand backslash escape sequences in
              the corresponding _a_r_g_u_m_e_n_t (except that  \\cc  terminates  output,
              backslashes in \\'', \\"", and \\?? are not removed, and octal escapes
              beginning with \\00 may contain up to four digits), and %%qq  causes
              pprriinnttff to output the corresponding _a_r_g_u_m_e_n_t in a format that can
              be reused as shell input.

              The --vv option causes the output to be assigned to  the  variable
              _v_a_r rather than being printed to the standard output.

              The  _f_o_r_m_a_t  is  reused as necessary to consume all of the _a_r_g_u_-
              _m_e_n_t_s.  If the _f_o_r_m_a_t requires more _a_r_g_u_m_e_n_t_s than are supplied,
              the  extra  format  specifications  behave as if a zero value or
              null string, as appropriate,  had  been  supplied.   The  return
              value is zero on success, non-zero on failure.

       ppuusshhdd [--nn] [+_n] [-_n]
       ppuusshhdd [--nn] [_d_i_r]
              Adds  a  directory to the top of the directory stack, or rotates
              the stack, making the new top of the stack the  current  working
              directory.  With no arguments, exchanges the top two directories
              and returns 0, unless the directory stack is empty.   Arguments,
              if supplied, have the following meanings:
              --nn     Suppresses  the  normal  change  of directory when adding
                     directories to the stack,  so  that  only  the  stack  is
                     manipulated.
              ++_n     Rotates  the  stack  so  that the _nth directory (counting
                     from the left of the list shown by  ddiirrss,  starting  with
                     zero) is at the top.
              --_n     Rotates  the  stack  so  that the _nth directory (counting
                     from the right of the list shown by ddiirrss,  starting  with
                     zero) is at the top.
              _d_i_r    Adds _d_i_r to the directory stack at the top, making it the
                     new current working directory.

              If the ppuusshhdd command is successful, a ddiirrss is performed as well.
              If  the first form is used, ppuusshhdd returns 0 unless the cd to _d_i_r
              fails.  With the second form, ppuusshhdd returns 0 unless the  direc-
              tory  stack  is empty, a non-existent directory stack element is
              specified, or the directory change to the specified new  current
              directory fails.

       ppwwdd [--LLPP]
              Print  the  absolute  pathname of the current working directory.
              The pathname printed contains no symbolic links if the --PP option
              is supplied or the --oo pphhyyssiiccaall option to the sseett builtin command
              is enabled.  If the --LL option is used, the pathname printed  may
              contain  symbolic links.  The return status is 0 unless an error
              occurs while reading the name of the  current  directory  or  an
              invalid option is supplied.

       rreeaadd [--eerrss] [--aa _a_n_a_m_e] [--dd _d_e_l_i_m] [--ii _t_e_x_t] [--nn _n_c_h_a_r_s] [--NN _n_c_h_a_r_s] [--pp
       _p_r_o_m_p_t] [--tt _t_i_m_e_o_u_t] [--uu _f_d] [_n_a_m_e ...]
              One  line  is  read  from  the  standard input, or from the file
              descriptor _f_d supplied as an argument to the --uu option, and  the
              first word is assigned to the first _n_a_m_e, the second word to the
              second _n_a_m_e, and so on, with leftover words and their  interven-
              ing  separators  assigned  to the last _n_a_m_e.  If there are fewer
              words read from the input stream than names, the remaining names
              are  assigned  empty  values.  The characters in IIFFSS are used to
              split the line into words.  The backslash character (\\)  may  be
              used  to  remove any special meaning for the next character read
              and for line continuation.  Options, if supplied, have the  fol-
              lowing meanings:
              --aa _a_n_a_m_e
                     The words are assigned to sequential indices of the array
                     variable _a_n_a_m_e, starting at 0.  _a_n_a_m_e is unset before any
                     new  values  are  assigned.   Other  _n_a_m_e  arguments  are
                     ignored.
              --dd _d_e_l_i_m
                     The first character of _d_e_l_i_m is  used  to  terminate  the
                     input line, rather than newline.
              --ee     If the standard input is coming from a terminal, rreeaaddlliinnee
                     (see RREEAADDLLIINNEE above) is used to obtain the  line.   Read-
                     line  uses  the  current (or default, if line editing was
                     not previously active) editing settings.
              --ii _t_e_x_t
                     If rreeaaddlliinnee is being used  to  read  the  line,  _t_e_x_t  is
                     placed into the editing buffer before editing begins.
              --nn _n_c_h_a_r_s
                     rreeaadd  returns after reading _n_c_h_a_r_s characters rather than
                     waiting for a complete line of input, but honor a  delim-
                     iter  if fewer than _n_c_h_a_r_s characters are read before the
                     delimiter.
              --NN _n_c_h_a_r_s
                     rreeaadd returns  after  reading  exactly  _n_c_h_a_r_s  characters
                     rather  than waiting for a complete line of input, unless
                     EOF is encountered or rreeaadd times out.  Delimiter  charac-
                     ters  encountered  in the input are not treated specially
                     and do not cause rreeaadd to return until  _n_c_h_a_r_s  characters
                     are read.
              --pp _p_r_o_m_p_t
                     Display _p_r_o_m_p_t on standard error, without a trailing new-
                     line, before attempting to read any input.  The prompt is
                     displayed only if input is coming from a terminal.
              --rr     Backslash does not act as an escape character.  The back-
                     slash is considered to be part of the line.  In  particu-
                     lar,  a  backslash-newline pair may not be used as a line
                     continuation.
              --ss     Silent mode.  If input is coming from a terminal, charac-
                     ters are not echoed.
              --tt _t_i_m_e_o_u_t
                     Cause  rreeaadd  to time out and return failure if a complete
                     line of input is not read within _t_i_m_e_o_u_t seconds.   _t_i_m_e_-
                     _o_u_t  may  be  a  decimal number with a fractional portion
                     following the decimal point.  This option is only  effec-
                     tive  if  rreeaadd is reading input from a terminal, pipe, or
                     other special file; it has no effect  when  reading  from
                     regular  files.  If _t_i_m_e_o_u_t is 0, rreeaadd returns success if
                     input is available  on  the  specified  file  descriptor,
                     failure  otherwise.   The exit status is greater than 128
                     if the timeout is exceeded.
              --uu _f_d  Read input from file descriptor _f_d.

              If no _n_a_m_e_s are supplied, the line read is assigned to the vari-
              able  RREEPPLLYY.   The  return  code  is zero, unless end-of-file is
              encountered, rreeaadd times out (in which case the  return  code  is
              greater  than 128), or an invalid file descriptor is supplied as
              the argument to --uu.

       rreeaaddoonnllyy [--aaAAppff] [_n_a_m_e[=_w_o_r_d] ...]
              The given _n_a_m_e_s are marked readonly; the values of  these  _n_a_m_e_s
              may  not  be changed by subsequent assignment.  If the --ff option
              is supplied, the functions corresponding to  the  _n_a_m_e_s  are  so
              marked.   The  --aa  option  restricts  the  variables  to indexed
              arrays; the --AA option restricts  the  variables  to  associative
              arrays.   If no _n_a_m_e arguments are given, or if the --pp option is
              supplied, a list of all  readonly  names  is  printed.   The  --pp
              option  causes  output  to  be displayed in a format that may be
              reused as input.  If a variable name is followed by  =_w_o_r_d,  the
              value  of  the  variable is set to _w_o_r_d.  The return status is 0
              unless an invalid option is encountered, one of the _n_a_m_e_s is not
              a  valid shell variable name, or --ff is supplied with a _n_a_m_e that
              is not a function.

       rreettuurrnn [_n]
              Causes a function to exit with the return value specified by  _n.
              If  _n  is omitted, the return status is that of the last command
              executed in the function body.  If used outside a function,  but
              during  execution  of  a  script  by the ..  (ssoouurrccee) command, it
              causes the shell to stop executing that script and return either
              _n  or  the  exit  status of the last command executed within the
              script as the exit status of the  script.   If  used  outside  a
              function  and  not during execution of a script by .., the return
              status is false.  Any command associated with the RREETTUURRNN trap is
              executed  before execution resumes after the function or script.

       sseett [----aabbeeffhhkkmmnnppttuuvvxxBBCCEEHHPPTT] [--oo _o_p_t_i_o_n] [_a_r_g ...]
       sseett [++aabbeeffhhkkmmnnppttuuvvxxBBCCEEHHPPTT] [++oo _o_p_t_i_o_n] [_a_r_g ...]
              Without options, the name and value of each shell  variable  are
              displayed in a format that can be reused as input for setting or
              resetting the currently-set variables.  Read-only variables can-
              not  be  reset.  In _p_o_s_i_x _m_o_d_e, only shell variables are listed.
              The output is sorted according  to  the  current  locale.   When
              options  are specified, they set or unset shell attributes.  Any
              arguments remaining after option processing are treated as  val-
              ues for the positional parameters and are assigned, in order, to
              $$11, $$22, ......  $$_n.  Options,  if  specified,  have  the  following
              meanings:
              --aa      Automatically  mark  variables  and  functions which are
                      modified or created for export  to  the  environment  of
                      subsequent commands.
              --bb      Report  the status of terminated background jobs immedi-
                      ately, rather than before the next primary prompt.  This
                      is effective only when job control is enabled.
              --ee      Exit  immediately  if a _p_i_p_e_l_i_n_e (which may consist of a
                      single _s_i_m_p_l_e _c_o_m_m_a_n_d),  a _s_u_b_s_h_e_l_l command enclosed  in
                      parentheses,  or one of the commands executed as part of
                      a command list enclosed by  braces  (see  SSHHEELLLL  GGRRAAMMMMAARR
                      above) exits with a non-zero status.  The shell does not
                      exit if the command that fails is part  of  the  command
                      list  immediately  following  a  wwhhiillee or uunnttiill keyword,
                      part of the test  following  the  iiff  or  eelliiff  reserved
                      words,  part  of any command executed in a &&&& or ││││ list
                      except the command following the final  &&&&  or  ││││,  any
                      command  in a pipeline but the last, or if the command’s
                      return value is being inverted with !!.  A trap  on  EERRRR,
                      if set, is executed before the shell exits.  This option
                      applies to the shell environment and each subshell envi-
                      ronment  separately  (see  CCOOMMMMAANNDD EEXXEECCUUTTIIOONN EENNVVIIRROONNMMEENNTT
                      above), and may cause subshells to exit before executing
                      all the commands in the subshell.
              --ff      Disable pathname expansion.
              --hh      Remember  the location of commands as they are looked up
                      for execution.  This is enabled by default.
              --kk      All arguments in the form of assignment  statements  are
                      placed  in the environment for a command, not just those
                      that precede the command name.
              --mm      Monitor mode.  Job control is enabled.  This  option  is
                      on  by  default  for  interactive shells on systems that
                      support it (see JJOOBB  CCOONNTTRROOLL  above).   Background  pro-
                      cesses  run  in a separate process group and a line con-
                      taining their exit status is printed upon their  comple-
                      tion.
              --nn      Read commands but do not execute them.  This may be used
                      to check a shell script  for  syntax  errors.   This  is
                      ignored by interactive shells.
              --oo _o_p_t_i_o_n_-_n_a_m_e
                      The _o_p_t_i_o_n_-_n_a_m_e can be one of the following:
                      aalllleexxppoorrtt
                              Same as --aa.
                      bbrraacceeeexxppaanndd
                              Same as --BB.
                      eemmaaccss   Use  an  emacs-style command line editing inter-
                              face.  This is enabled by default when the shell
                              is interactive, unless the shell is started with
                              the ----nnooeeddiittiinngg option.  This also  affects  the
                              editing interface used for rreeaadd --ee.
                      eerrrreexxiitt Same as --ee.
                      eerrrrttrraaccee
                              Same as --EE.
                      ffuunnccttrraaccee
                              Same as --TT.
                      hhaasshhaallll Same as --hh.
                      hhiisstteexxppaanndd
                              Same as --HH.
                      hhiissttoorryy Enable command history, as described above under
                              HHIISSTTOORRYY.  This option is on by default in inter-
                              active shells.
                      iiggnnoorreeeeooff
                              The   effect   is   as   if  the  shell  command
                              ‘‘IGNOREEOF=10’’ had been  executed  (see  SShheellll
                              VVaarriiaabblleess above).
                      kkeeyywwoorrdd Same as --kk.
                      mmoonniittoorr Same as --mm.
                      nnoocclloobbbbeerr
                              Same as --CC.
                      nnooeexxeecc  Same as --nn.
                      nnoogglloobb  Same as --ff.
                      nnoolloogg   Currently ignored.
                      nnoottiiffyy  Same as --bb.
                      nnoouunnsseett Same as --uu.
                      oonneeccmmdd  Same as --tt.
                      pphhyyssiiccaall
                              Same as --PP.
                      ppiippeeffaaiill
                              If  set,  the  return value of a pipeline is the
                              value of the last (rightmost)  command  to  exit
                              with  a non-zero status, or zero if all commands
                              in the pipeline exit successfully.  This  option
                              is disabled by default.
                      ppoossiixx   Change  the  behavior  of bbaasshh where the default
                              operation differs from  the  POSIX  standard  to
                              match the standard (_p_o_s_i_x _m_o_d_e).
                      pprriivviilleeggeedd
                              Same as --pp.
                      vveerrbboossee Same as --vv.
                      vvii      Use  a  vi-style command line editing interface.
                              This also affects the editing interface used for
                              rreeaadd --ee.
                      xxttrraaccee  Same as --xx.
                      If --oo is supplied with no _o_p_t_i_o_n_-_n_a_m_e, the values of the
                      current options are printed.  If ++oo is supplied with  no
                      _o_p_t_i_o_n_-_n_a_m_e,  a  series  of sseett commands to recreate the
                      current option settings is  displayed  on  the  standard
                      output.
              --pp      Turn  on  _p_r_i_v_i_l_e_g_e_d  mode.   In this mode, the $$EENNVV and
                      $$BBAASSHH__EENNVV files are not processed, shell  functions  are
                      not  inherited  from the environment, and the SSHHEELLLLOOPPTTSS,
                      BBAASSHHOOPPTTSS, CCDDPPAATTHH,  and  GGLLOOBBIIGGNNOORREE  variables,  if  they
                      appear in the environment, are ignored.  If the shell is
                      started with the effective user (group) id not equal  to
                      the  real user (group) id, and the --pp option is not sup-
                      plied, these actions are taken and the effective user id
                      is  set  to  the real user id.  If the --pp option is sup-
                      plied at startup, the effective user id  is  not  reset.
                      Turning  this  option  off causes the effective user and
                      group ids to be set to the real user and group ids.
              --tt      Exit after reading and executing one command.
              --uu      Treat unset variables and parameters other than the spe-
                      cial  parameters "@" and "*" as an error when performing
                      parameter expansion.  If expansion is  attempted  on  an
                      unset  variable  or parameter, the shell prints an error
                      message, and, if not interactive, exits with a  non-zero
                      status.
              --vv      Print shell input lines as they are read.
              --xx      After  expanding  each _s_i_m_p_l_e _c_o_m_m_a_n_d, ffoorr command, ccaassee
                      command, sseelleecctt command, or arithmetic ffoorr command, dis-
                      play  the expanded value of PPSS44, followed by the command
                      and its expanded arguments or associated word list.
              --BB      The shell performs brace expansion (see BBrraaccee  EExxppaannssiioonn
                      above).  This is on by default.
              --CC      If  set,  bbaasshh  does not overwrite an existing file with
                      the >>, >>&&, and <<>> redirection operators.   This  may  be
                      overridden when creating output files by using the redi-
                      rection operator >>|| instead of >>.
              --EE      If set, any trap on EERRRR is inherited by shell functions,
                      command  substitutions,  and commands executed in a sub-
                      shell environment.  The EERRRR trap is normally not  inher-
                      ited in such cases.
              --HH      Enable !!  style history substitution.  This option is on
                      by default when the shell is interactive.
              --PP      If set, the shell does not follow  symbolic  links  when
                      executing  commands  such  as ccdd that change the current
                      working  directory.   It  uses  the  physical  directory
                      structure instead.  By default, bbaasshh follows the logical
                      chain of  directories  when  performing  commands  which
                      change the current directory.
              --TT      If  set,  any traps on DDEEBBUUGG and RREETTUURRNN are inherited by
                      shell functions,  command  substitutions,  and  commands
                      executed  in  a  subshell  environment.   The  DDEEBBUUGG and
                      RREETTUURRNN traps are normally not inherited in such cases.
              ----      If no arguments follow this option, then the  positional
                      parameters are unset.  Otherwise, the positional parame-
                      ters are set to the _a_r_gs, even if  some  of  them  begin
                      with a --.
              --       Signal  the  end of options, cause all remaining _a_r_gs to
                      be assigned to the positional parameters.  The --xx and --vv
                      options are turned off.  If there are no _a_r_gs, the posi-
                      tional parameters remain unchanged.

              The options are off by default unless otherwise noted.  Using  +
              rather  than  -  causes  these  options  to  be turned off.  The
              options can also be specified as arguments to an  invocation  of
              the  shell.  The current set of options may be found in $$--.  The
              return status is always true unless an invalid option is encoun-
              tered.

       sshhiifftt [_n]
              The  positional  parameters  from _n+1 ... are renamed to $$11 ........
              Parameters represented by the numbers  $$##  down  to  $$##-_n+1  are
              unset.   _n  must  be a non-negative number less than or equal to
              $$##.  If _n is 0, no parameters are changed.  If _n is  not  given,
              it  is assumed to be 1.  If _n is greater than $$##, the positional
              parameters are not changed.  The return status is  greater  than
              zero if _n is greater than $$## or less than zero; otherwise 0.

       sshhoopptt [--ppqqssuu] [--oo] [_o_p_t_n_a_m_e ...]
              Toggle the values of variables controlling optional shell behav-
              ior.  With no options, or with the --pp option, a list of all set-
              table options is displayed, with an indication of whether or not
              each is set.  The --pp option causes output to be displayed  in  a
              form  that  may be reused as input.  Other options have the fol-
              lowing meanings:
              --ss     Enable (set) each _o_p_t_n_a_m_e.
              --uu     Disable (unset) each _o_p_t_n_a_m_e.
              --qq     Suppresses normal output (quiet mode); the return  status
                     indicates whether the _o_p_t_n_a_m_e is set or unset.  If multi-
                     ple _o_p_t_n_a_m_e arguments are given with --qq, the return  sta-
                     tus  is zero if all _o_p_t_n_a_m_e_s are enabled; non-zero other-
                     wise.
              --oo     Restricts the values of _o_p_t_n_a_m_e to be those  defined  for
                     the --oo option to the sseett builtin.

              If  either  --ss or --uu is used with no _o_p_t_n_a_m_e arguments, the dis-
              play is limited to those options which are set or unset, respec-
              tively.   Unless otherwise noted, the sshhoopptt options are disabled
              (unset) by default.

              The return status when listing options is zero if  all  _o_p_t_n_a_m_e_s
              are  enabled,  non-zero  otherwise.   When  setting or unsetting
              options, the return status is zero unless an _o_p_t_n_a_m_e  is  not  a
              valid shell option.

              The list of sshhoopptt options is:

              aauuttooccdd  If  set,  a command name that is the name of a directory
                      is executed as if it were the argument to  the  ccdd  com-
                      mand.  This option is only used by interactive shells.
              ccddaabbllee__vvaarrss
                      If  set,  an  argument to the ccdd builtin command that is
                      not a directory is assumed to be the name of a  variable
                      whose value is the directory to change to.
              ccddssppeellll If set, minor errors in the spelling of a directory com-
                      ponent in a ccdd command will be  corrected.   The  errors
                      checked for are transposed characters, a missing charac-
                      ter, and one character too many.   If  a  correction  is
                      found,  the corrected file name is printed, and the com-
                      mand proceeds.  This option is only used by  interactive
                      shells.
              cchheecckkhhaasshh
                      If set, bbaasshh checks that a command found in the hash ta-
                      ble exists before trying to execute  it.   If  a  hashed
                      command  no  longer exists, a normal path search is per-
                      formed.
              cchheecckkjjoobbss
                      If set, bbaasshh lists the status of any stopped and running
                      jobs  before  exiting an interactive shell.  If any jobs
                      are running, this causes the exit to be deferred until a
                      second  exit is attempted without an intervening command
                      (see JJOOBB CCOONNTTRROOLL above).   The  shell  always  postpones
                      exiting if any jobs are stopped.
              cchheecckkwwiinnssiizzee
                      If  set,  bbaasshh checks the window size after each command
                      and, if necessary,  updates  the  values  of  LLIINNEESS  and
                      CCOOLLUUMMNNSS.
              ccmmddhhiisstt If  set,  bbaasshh attempts to save all lines of a multiple-
                      line command in the same  history  entry.   This  allows
                      easy re-editing of multi-line commands.
              ccoommppaatt3311
                      If set, bbaasshh changes its behavior to that of version 3.1
                      with respect to  quoted  arguments  to  the  conditional
                      command’s =~ operator.
              ccoommppaatt3322
                      If set, bbaasshh changes its behavior to that of version 3.2
                      with respect to locale-specific string  comparison  when
                      using the conditional command’s < and > operators.
              ccoommppaatt4400
                      If set, bbaasshh changes its behavior to that of version 4.0
                      with respect to locale-specific string  comparison  when
                      using  the  conditional  command’s < and > operators and
                      the effect of interrupting a command list.
              ddiirrssppeellll
                      If set, bbaasshh attempts spelling correction  on  directory
                      names  during word completion if the directory name ini-
                      tially supplied does not exist.
              ddoottgglloobb If set, bbaasshh includes filenames beginning with a ‘.’  in
                      the results of pathname expansion.
              eexxeeccffaaiill
                      If set, a non-interactive shell will not exit if it can-
                      not execute the file specified as  an  argument  to  the
                      eexxeecc  builtin  command.   An  interactive shell does not
                      exit if eexxeecc fails.
              eexxppaanndd__aalliiaasseess
                      If set, aliases are expanded as  described  above  under
                      AALLIIAASSEESS.  This option is enabled by default for interac-
                      tive shells.
              eexxttddeebbuugg
                      If set,  behavior  intended  for  use  by  debuggers  is
                      enabled:
                      11..     The --FF option to the ddeeccllaarree builtin displays the
                             source file name and line number corresponding to
                             each function name supplied as an argument.
                      22..     If  the  command  run by the DDEEBBUUGG trap returns a
                             non-zero value, the next command is  skipped  and
                             not executed.
                      33..     If  the  command  run by the DDEEBBUUGG trap returns a
                             value of 2, and the shell is executing in a  sub-
                             routine  (a shell function or a shell script exe-
                             cuted by the .. or ssoouurrccee  builtins),  a  call  to
                             rreettuurrnn is simulated.
                      44..     BBAASSHH__AARRGGCC  and BBAASSHH__AARRGGVV are updated as described
                             in their descriptions above.
                      55..     Function tracing is enabled:   command  substitu-
                             tion, shell functions, and subshells invoked with
                             (( _c_o_m_m_a_n_d )) inherit the DDEEBBUUGG and RREETTUURRNN traps.
                      66..     Error tracing is enabled:  command  substitution,
                             shell  functions,  and  subshells  invoked with ((
                             _c_o_m_m_a_n_d )) inherit the EERRRROORR trap.
              eexxttgglloobb If set, the extended pattern matching features described
                      above under PPaatthhnnaammee EExxppaannssiioonn are enabled.
              eexxttqquuoottee
                      If  set,  $$'_s_t_r_i_n_g'  and  $$"_s_t_r_i_n_g" quoting is performed
                      within  $${{_p_a_r_a_m_e_t_e_r}}  expansions  enclosed   in   double
                      quotes.  This option is enabled by default.
              ffaaiillgglloobb
                      If  set,  patterns  which fail to match filenames during
                      pathname expansion result in an expansion error.
              ffoorrccee__ffiiggnnoorree
                      If set, the suffixes  specified  by  the  FFIIGGNNOORREE  shell
                      variable  cause words to be ignored when performing word
                      completion even if the ignored words are the only possi-
                      ble  completions.   See  SSHHEELLLL  VVAARRIIAABBLLEESS  above  for  a
                      description of  FFIIGGNNOORREE.   This  option  is  enabled  by
                      default.
              gglloobbssttaarr
                      If set, the pattern **** used in a pathname expansion con-
                      text will match a files and zero or more directories and
                      subdirectories.  If the pattern is followed by a //, only
                      directories and subdirectories match.
              ggnnuu__eerrrrffmmtt
                      If set, shell error messages are written in the standard
                      GNU error message format.
              hhiissttaappppeenndd
                      If  set,  the history list is appended to the file named
                      by the value of the HHIISSTTFFIILLEE  variable  when  the  shell
                      exits, rather than overwriting the file.
              hhiissttrreeeeddiitt
                      If  set, and rreeaaddlliinnee is being used, a user is given the
                      opportunity to re-edit a failed history substitution.
              hhiissttvveerriiffyy
                      If set, and rreeaaddlliinnee is being used, the results of  his-
                      tory  substitution  are  not  immediately  passed to the
                      shell parser.  Instead, the  resulting  line  is  loaded
                      into the rreeaaddlliinnee editing buffer, allowing further modi-
                      fication.
              hhoossttccoommpplleettee
                      If set, and rreeaaddlliinnee is being used, bbaasshh will attempt to
                      perform  hostname  completion when a word containing a @@
                      is  being  completed  (see  CCoommpplleettiinngg  under   RREEAADDLLIINNEE
                      above).  This is enabled by default.
              hhuuppoonneexxiitt
                      If set, bbaasshh will send SSIIGGHHUUPP to all jobs when an inter-
                      active login shell exits.
              iinntteerraaccttiivvee__ccoommmmeennttss
                      If set, allow a word beginning with ## to cause that word
                      and  all remaining characters on that line to be ignored
                      in an interactive  shell  (see  CCOOMMMMEENNTTSS  above).   This
                      option is enabled by default.
              lliitthhiisstt If  set,  and  the ccmmddhhiisstt option is enabled, multi-line
                      commands are saved to the history with embedded newlines
                      rather than using semicolon separators where possible.
              llooggiinn__sshheellll
                      The  shell  sets this option if it is started as a login
                      shell (see IINNVVOOCCAATTIIOONN above).   The  value  may  not  be
                      changed.
              mmaaiillwwaarrnn
                      If  set,  and  a file that bbaasshh is checking for mail has
                      been accessed since the last time it  was  checked,  the
                      message  ‘‘The  mail in _m_a_i_l_f_i_l_e has been read’’ is dis-
                      played.
              nnoo__eemmppttyy__ccmmdd__ccoommpplleettiioonn
                      If set, and  rreeaaddlliinnee  is  being  used,  bbaasshh  will  not
                      attempt to search the PPAATTHH for possible completions when
                      completion is attempted on an empty line.
              nnooccaasseegglloobb
                      If set, bbaasshh matches  filenames  in  a  case-insensitive
                      fashion when performing pathname expansion (see PPaatthhnnaammee
                      EExxppaannssiioonn above).
              nnooccaasseemmaattcchh
                      If set, bbaasshh  matches  patterns  in  a  case-insensitive
                      fashion when performing matching while executing ccaassee or
                      [[[[ conditional commands.
              nnuullllgglloobb
                      If set, bbaasshh allows patterns which match no  files  (see
                      PPaatthhnnaammee  EExxppaannssiioonn  above)  to expand to a null string,
                      rather than themselves.
              pprrooggccoommpp
                      If set, the programmable completion facilities (see PPrroo--
                      ggrraammmmaabbllee CCoommpplleettiioonn above) are enabled.  This option is
                      enabled by default.
              pprroommppttvvaarrss
                      If set, prompt strings undergo parameter expansion, com-
                      mand   substitution,  arithmetic  expansion,  and  quote
                      removal after being expanded as described  in  PPRROOMMPPTTIINNGG
                      above.  This option is enabled by default.
              rreessttrriicctteedd__sshheellll
                      The   shell  sets  this  option  if  it  is  started  in
                      restricted mode (see RREESSTTRRIICCTTEEDD SSHHEELLLL below).  The value
                      may  not be changed.  This is not reset when the startup
                      files are executed, allowing the startup files  to  dis-
                      cover whether or not a shell is restricted.
              sshhiifftt__vveerrbboossee
                      If  set,  the sshhiifftt builtin prints an error message when
                      the shift count exceeds the number of positional parame-
                      ters.
              ssoouurrcceeppaatthh
                      If set, the ssoouurrccee (..) builtin uses the value of PPAATTHH to
                      find the directory containing the file  supplied  as  an
                      argument.  This option is enabled by default.
              xxppgg__eecchhoo
                      If   set,  the  eecchhoo  builtin  expands  backslash-escape
                      sequences by default.
       ssuussppeenndd [--ff]
              Suspend the execution of this shell until it receives a  SSIIGGCCOONNTT
              signal. When the suspended shell is a background process, it can
              be restarted by the ffgg command. For more information,  read  the
              JJOOBB  CCOONNTTRROOLL  section.  The  ssuussppeenndd command can not suspend the
              login shell. However, when --ff option is specified, ssuussppeenndd  com-
              mand  can  suspend  even  login  shell.   The return status is 0
              unless the shell is a login shell and --ff is not supplied, or  if
              job control is not enabled.
       tteesstt _e_x_p_r
       [[ _e_x_p_r ]]
              Return  a  status  of  0 or 1 depending on the evaluation of the
              conditional expression _e_x_p_r.  Each operator and operand must  be
              a  separate argument.  Expressions are composed of the primaries
              described above under CCOONNDDIITTIIOONNAALL EEXXPPRREESSSSIIOONNSS.   tteesstt  does  not
              accept any options, nor does it accept and ignore an argument of
              ---- as signifying the end of options.

              Expressions may  be  combined  using  the  following  operators,
              listed  in  decreasing  order  of  precedence.   The  evaluation
              depends on the number of arguments; see below.
              !! _e_x_p_r True if _e_x_p_r is false.
              (( _e_x_p_r ))
                     Returns the value of _e_x_p_r.  This may be used to  override
                     the normal precedence of operators.
              _e_x_p_r_1 -aa _e_x_p_r_2
                     True if both _e_x_p_r_1 and _e_x_p_r_2 are true.
              _e_x_p_r_1 -oo _e_x_p_r_2
                     True if either _e_x_p_r_1 or _e_x_p_r_2 is true.

              tteesstt and [[ evaluate conditional expressions using a set of rules
              based on the number of arguments.

              0 arguments
                     The expression is false.
              1 argument
                     The expression is true if and only if the argument is not
                     null.
              2 arguments
                     If the first argument is !!, the expression is true if and
                     only if the second argument is null.  If the first  argu-
                     ment  is  one  of  the unary conditional operators listed
                     above under CCOONNDDIITTIIOONNAALL EEXXPPRREESSSSIIOONNSS,  the  expression  is
                     true if the unary test is true.  If the first argument is
                     not a valid unary conditional operator, the expression is
                     false.
              3 arguments
                     If  the  second argument is one of the binary conditional
                     operators listed above under CCOONNDDIITTIIOONNAALL EEXXPPRREESSSSIIOONNSS, the
                     result of the expression is the result of the binary test
                     using the first and third arguments as operands.  The  --aa
                     and  --oo  operators  are  considered binary operators when
                     there are three arguments.  If the first argument  is  !!,
                     the  value is the negation of the two-argument test using
                     the second and third arguments.  If the first argument is
                     exactly (( and the third argument is exactly )), the result
                     is the one-argument test of the second argument.   Other-
                     wise, the expression is false.
              4 arguments
                     If the first argument is !!, the result is the negation of
                     the three-argument expression composed of  the  remaining
                     arguments.  Otherwise, the expression is parsed and eval-
                     uated according to  precedence  using  the  rules  listed
                     above.
              5 or more arguments
                     The  expression  is  parsed  and  evaluated  according to
                     precedence using the rules listed above.

       ttiimmeess  Print the accumulated user and system times for  the  shell  and
              for processes run from the shell.  The return status is 0.

       ttrraapp [--llpp] [[_a_r_g] _s_i_g_s_p_e_c ...]
              The  command  _a_r_g  is  to  be  read  and executed when the shell
              receives signal(s) _s_i_g_s_p_e_c.  If _a_r_g is absent (and  there  is  a
              single  _s_i_g_s_p_e_c)  or  --,  each  specified signal is reset to its
              original disposition (the value it  had  upon  entrance  to  the
              shell).   If _a_r_g is the null string the signal specified by each
              _s_i_g_s_p_e_c is ignored by the shell and by the commands it  invokes.
              If  _a_r_g  is  not present and --pp has been supplied, then the trap
              commands associated with each  _s_i_g_s_p_e_c  are  displayed.   If  no
              arguments  are  supplied or if only --pp is given, ttrraapp prints the
              list of commands associated with each  signal.   The  --ll  option
              causes  the shell to print a list of signal names and their cor-
              responding numbers.   Each  _s_i_g_s_p_e_c  is  either  a  signal  name
              defined  in  <_s_i_g_n_a_l_._h>,  or  a signal number.  Signal names are
              case insensitive and the SIG prefix is optional.

              If a _s_i_g_s_p_e_c is EEXXIITT (0) the command _a_r_g  is  executed  on  exit
              from  the shell.  If a _s_i_g_s_p_e_c is DDEEBBUUGG, the command _a_r_g is exe-
              cuted before every _s_i_m_p_l_e _c_o_m_m_a_n_d, _f_o_r  command,  _c_a_s_e  command,
              _s_e_l_e_c_t  command,  every  arithmetic  _f_o_r command, and before the
              first command executes in a shell function  (see  SSHHEELLLL  GGRRAAMMMMAARR
              above).   Refer to the description of the eexxttddeebbuugg option to the
              sshhoopptt builtin for details of its effect on the DDEEBBUUGG trap.  If a
              _s_i_g_s_p_e_c is RREETTUURRNN, the command _a_r_g is executed each time a shell
              function or a script executed with the .. or ssoouurrccee builtins fin-
              ishes executing.

              If a _s_i_g_s_p_e_c is EERRRR, the command _a_r_g is executed whenever a sim-
              ple command has a non-zero exit status, subject to the following
              conditions.   The EERRRR trap is not executed if the failed command
              is part of the command list immediately  following  a  wwhhiillee  or
              uunnttiill  keyword,  part  of the test in an _i_f statement, part of a
              command executed in a &&&& or ││││ list, or if the command’s  return
              value  is  being  inverted via !!.  These are the same conditions
              obeyed by the eerrrreexxiitt option.

              Signals ignored upon entry to the shell cannot be trapped, reset
              or listed.  Trapped signals that are not being ignored are reset
              to their original values in a subshell or  subshell  environment
              when  one is created.  The return status is false if any _s_i_g_s_p_e_c
              is invalid; otherwise ttrraapp returns true.

       ttyyppee [--aaffttppPP] _n_a_m_e [_n_a_m_e ...]
              With no options, indicate how each _n_a_m_e would be interpreted  if
              used as a command name.  If the --tt option is used, ttyyppee prints a
              string which is one of _a_l_i_a_s,  _k_e_y_w_o_r_d,  _f_u_n_c_t_i_o_n,  _b_u_i_l_t_i_n,  or
              _f_i_l_e  if  _n_a_m_e  is  an  alias,  shell  reserved  word, function,
              builtin, or disk file, respectively.  If the _n_a_m_e is not  found,
              then  nothing  is  printed,  and  an  exit  status  of  false is
              returned.  If the --pp option is used,  ttyyppee  either  returns  the
              name of the disk file that would be executed if _n_a_m_e were speci-
              fied as a command name, or nothing if ‘‘type -t name’’ would not
              return  _f_i_l_e.  The --PP option forces a PPAATTHH search for each _n_a_m_e,
              even if ‘‘type -t name’’ would not return _f_i_l_e.  If a command is
              hashed,  --pp  and  --PP print the hashed value, not necessarily the
              file that appears first in PPAATTHH.  If the --aa option is used, ttyyppee
              prints  all of the places that contain an executable named _n_a_m_e.
              This includes aliases and functions,  if  and  only  if  the  --pp
              option  is  not  also used.  The table of hashed commands is not
              consulted when using --aa.  The --ff option suppresses  shell  func-
              tion  lookup, as with the ccoommmmaanndd builtin.  ttyyppee returns true if
              all of the arguments are found, false if any are not found.

       uulliimmiitt [--HHSSTTaabbccddeeffiillmmnnppqqrrssttuuvvxx [_l_i_m_i_t]]
              Provides control over the resources available to the  shell  and
              to  processes started by it, on systems that allow such control.
              The --HH and --SS options specify that the hard or soft limit is set
              for  the  given resource.  A hard limit cannot be increased by a
              non-root user once it is set; a soft limit may be  increased  up
              to  the value of the hard limit.  If neither --HH nor --SS is speci-
              fied, both the soft and hard limits are set.  The value of _l_i_m_i_t
              can be a number in the unit specified for the resource or one of
              the special values hhaarrdd, ssoofftt, or uunnlliimmiitteedd, which stand for the
              current  hard  limit,  the  current  soft  limit,  and no limit,
              respectively.  If _l_i_m_i_t is omitted, the  current  value  of  the
              soft  limit  of the resource is printed, unless the --HH option is
              given.  When more than one resource is specified, the limit name
              and unit are printed before the value.  Other options are inter-
              preted as follows:
              --aa     All current limits are reported
              --bb     The maximum socket buffer size
              --cc     The maximum size of core files created
              --dd     The maximum size of a process’s data segment
              --ee     The maximum scheduling priority ("nice")
              --ff     The maximum size of files written by the  shell  and  its
                     children
              --ii     The maximum number of pending signals
              --ll     The maximum size that may be locked into memory
              --mm     The  maximum resident set size (many systems do not honor
                     this limit)
              --nn     The maximum number of open file descriptors (most systems
                     do not allow this value to be set)
              --pp     The pipe size in 512-byte blocks (this may not be set)
              --qq     The maximum number of bytes in POSIX message queues
              --rr     The maximum real-time scheduling priority
              --ss     The maximum stack size
              --tt     The maximum amount of cpu time in seconds
              --uu     The  maximum  number  of  processes available to a single
                     user
              --vv     The maximum amount of virtual  memory  available  to  the
                     shell
              --xx     The maximum number of file locks
              --TT     The maximum number of threads

              If _l_i_m_i_t is given, it is the new value of the specified resource
              (the --aa option is display only).  If no option is given, then --ff
              is  assumed.  Values are in 1024-byte increments, except for --tt,
              which is in seconds, --pp, which is in units of  512-byte  blocks,
              and  --TT,  --bb, --nn, and --uu, which are unscaled values.  The return
              status is 0 unless an invalid option or argument is supplied, or
              an error occurs while setting a new limit.

       uummaasskk [--pp] [--SS] [_m_o_d_e]
              The user file-creation mask is set to _m_o_d_e.  If _m_o_d_e begins with
              a digit, it is interpreted as an octal number; otherwise  it  is
              interpreted  as a symbolic mode mask similar to that accepted by
              _c_h_m_o_d(1).  If _m_o_d_e is omitted, the current value of the mask  is
              printed.   The  --SS  option causes the mask to be printed in sym-
              bolic form; the default output is an octal number.   If  the  --pp
              option is supplied, and _m_o_d_e is omitted, the output is in a form
              that may be reused as input.  The return status is 0 if the mode
              was  successfully  changed  or if no _m_o_d_e argument was supplied,
              and false otherwise.

       uunnaalliiaass [-aa] [_n_a_m_e ...]
              Remove each _n_a_m_e from the list of defined  aliases.   If  --aa  is
              supplied,  all  alias definitions are removed.  The return value
              is true unless a supplied _n_a_m_e is not a defined alias.

       uunnsseett [-ffvv] [_n_a_m_e ...]
              For each _n_a_m_e, remove the corresponding  variable  or  function.
              If no options are supplied, or the --vv option is given, each _n_a_m_e
              refers to a shell variable.   Read-only  variables  may  not  be
              unset.   If  --ff  is specified, each _n_a_m_e refers to a shell func-
              tion, and the function definition is removed.  Each unset  vari-
              able  or function is removed from the environment passed to sub-
              sequent commands.  If any of CCOOMMPP__WWOORRDDBBRREEAAKKSS,  RRAANNDDOOMM,  SSEECCOONNDDSS,
              LLIINNEENNOO,  HHIISSTTCCMMDD,  FFUUNNCCNNAAMMEE, GGRROOUUPPSS, or DDIIRRSSTTAACCKK are unset, they
              lose their special properties, even  if  they  are  subsequently
              reset.  The exit status is true unless a _n_a_m_e is readonly.

       wwaaiitt [_n _._._.]
              Wait  for each specified process and return its termination sta-
              tus.  Each _n may be a process ID or a job  specification;  if  a
              job  spec  is  given,  all  processes in that job’s pipeline are
              waited for.  If _n is not given, all currently active child  pro-
              cesses  are  waited  for,  and  the return status is zero.  If _n
              specifies a non-existent process or job, the  return  status  is
              127.   Otherwise,  the  return  status is the exit status of the
              last process or job waited for.

RREESSTTRRIICCTTEEDD SSHHEELLLL
       If bbaasshh is started with the name rrbbaasshh, or the --rr option is supplied at
       invocation,  the  shell becomes restricted.  A restricted shell is used
       to set up an environment more controlled than the standard  shell.   It
       behaves  identically  to bbaasshh with the exception that the following are
       disallowed or not performed:

       ·      changing directories with ccdd

       ·      setting or unsetting the values of SSHHEELLLL, PPAATTHH, EENNVV, or BBAASSHH__EENNVV

       ·      specifying command names containing //

       ·      specifying  a  file  name containing a // as an argument to the ..
              builtin command

       ·      Specifying a filename containing a slash as an argument  to  the
              --pp option to the hhaasshh builtin command

       ·      importing  function  definitions  from  the shell environment at
              startup

       ·      parsing the value of SSHHEELLLLOOPPTTSS from  the  shell  environment  at
              startup

       ·      redirecting  output using the >, >|, <>, >&, &>, and >> redirec-
              tion operators

       ·      using the eexxeecc builtin command to replace the shell with another
              command

       ·      adding  or  deleting builtin commands with the --ff and --dd options
              to the eennaabbllee builtin command

       ·      Using the  eennaabbllee  builtin  command  to  enable  disabled  shell
              builtins

       ·      specifying the --pp option to the ccoommmmaanndd builtin command

       ·      turning off restricted mode with sseett ++rr or sseett ++oo rreessttrriicctteedd.

       These restrictions are enforced after any startup files are read.

       When a command that is found to be a shell script is executed (see CCOOMM--
       MMAANNDD EEXXEECCUUTTIIOONN above), rrbbaasshh turns off any restrictions  in  the  shell
       spawned to execute the script.

SSEEEE AALLSSOO
       _B_a_s_h _R_e_f_e_r_e_n_c_e _M_a_n_u_a_l, Brian Fox and Chet Ramey
       _T_h_e _G_n_u _R_e_a_d_l_i_n_e _L_i_b_r_a_r_y, Brian Fox and Chet Ramey
       _T_h_e _G_n_u _H_i_s_t_o_r_y _L_i_b_r_a_r_y, Brian Fox and Chet Ramey
       _P_o_r_t_a_b_l_e  _O_p_e_r_a_t_i_n_g  _S_y_s_t_e_m  _I_n_t_e_r_f_a_c_e _(_P_O_S_I_X_) _P_a_r_t _2_: _S_h_e_l_l _a_n_d _U_t_i_l_i_-
       _t_i_e_s, IEEE
       _s_h(1), _k_s_h(1), _c_s_h(1)
       _e_m_a_c_s(1), _v_i(1)
       _r_e_a_d_l_i_n_e(3)

FFIILLEESS
       _/_b_i_n_/_b_a_s_h
              The bbaasshh executable
       _/_e_t_c_/_p_r_o_f_i_l_e
              The systemwide initialization file, executed for login shells
       _/_e_t_c_/_b_a_s_h_._b_a_s_h___l_o_g_o_u_t
              The  systemwide  login shell cleanup file, executed when a login
              shell exits
       _~_/_._b_a_s_h___p_r_o_f_i_l_e
              The personal initialization file, executed for login shells
       _~_/_._b_a_s_h_r_c
              The individual per-interactive-shell startup file
       _~_/_._b_a_s_h___l_o_g_o_u_t
              The individual login shell cleanup file, executed when  a  login
              shell exits
       _~_/_._i_n_p_u_t_r_c
              Individual _r_e_a_d_l_i_n_e initialization file

AAUUTTHHOORRSS
       Brian Fox, Free Software Foundation
       bfox@gnu.org

       Chet Ramey, Case Western Reserve University
       chet.ramey@case.edu

BBUUGG RREEPPOORRTTSS
       If you find a bug in bbaasshh,, you should report it.  But first, you should
       make sure that it really is a bug, and that it appears  in  the  latest
       version   of  bbaasshh.   The  latest  version  is  always  available  from
       _f_t_p_:_/_/_f_t_p_._g_n_u_._o_r_g_/_p_u_b_/_b_a_s_h_/.

       Once you have determined that a bug actually exists,  use  the  _b_a_s_h_b_u_g
       command  (from the source package) to submit a bug report.  If you have
       a fix, you are encouraged  to  mail  that  as  well!   Suggestions  and
       ‘philosophical’ bug reports may be mailed to _b_u_g_-_b_a_s_h_@_g_n_u_._o_r_g or posted
       to the Usenet newsgroup ggnnuu..bbaasshh..bbuugg.

       ALL bug reports should include:

       The version number of bbaasshh
       The hardware and operating system
       The compiler used to compile
       A description of the bug behaviour
       A short script or ‘recipe’ which exercises the bug

       Comments and bug reports concerning this manual page should be directed
       to _c_h_e_t_@_p_o_._c_w_r_u_._e_d_u.

BBUUGGSS
       It’s too big and too slow.

       There are some subtle differences between bbaasshh and traditional versions
       of sshh, mostly because of the PPOOSSIIXX specification.

       Aliases are confusing in some uses.

       Shell builtin commands and functions are not stoppable/restartable.

       Compound commands and command sequences of the form ‘a ; b ; c’ are not
       handled  gracefully  when process suspension is attempted.  When a pro-
       cess is stopped, the shell immediately executes the next command in the
       sequence.  It suffices to place the sequence of commands between paren-
       theses to force it into a subshell, which may be stopped as a unit.

       Array variables may not (yet) be exported.

       There may be only one active coprocess at a time.



GNU Bash-4.1                   2009 December 29                        BASH(1)
